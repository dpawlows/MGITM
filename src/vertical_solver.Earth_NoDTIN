
!\
! ------------------------------------------------------------
! advance
! ------------------------------------------------------------
!/

subroutine advance_vertical_1d

  use ModVertical
  use ModGITM, ONLY : Dt, iCommGITM, iProc, iEast_, iNorth_, iUp_
  use ModInputs, only: UseBarriers, iDebugLevel
  use ModPlanet, only: iN2_
  implicit none
  !-----------------------------------------------------------

  integer :: iError, iAlt


!!!!! Variables for the Runga-Kutta (3) Time-stepping
  real :: OrigLogNS(-1:nAlts+2,1:nSpecies)
  real :: OrigLogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: OrigLogRho(-1:nAlts+2)
  real :: OrigVel_GD(-1:nAlts+2,1:3)
  real :: OrigTemp(-1:nAlts+2)
  real :: OrigVertVel(-1:nAlts+2,1:nSpecies)

  real :: UpdatedLogNS(-1:nAlts+2,1:nSpecies)
  real :: UpdatedLogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: UpdatedLogRho(-1:nAlts+2)
  real :: UpdatedVel_GD(-1:nAlts+2,1:3)
  real :: UpdatedTemp(-1:nAlts+2)
  real :: UpdatedVertVel(-1:nAlts+2,1:nSpecies)

  real :: K1LogNS(-1:nAlts+2,1:nSpecies)
  real :: K1LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: K1LogRho(-1:nAlts+2)
  real :: K1Vel_GD(-1:nAlts+2,1:3)
  real :: K1Temp(-1:nAlts+2)
  real :: K1VertVel(-1:nAlts+2,1:nSpecies)

  real :: K2LogNS(-1:nAlts+2,1:nSpecies)
  real :: K2LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: K2LogRho(-1:nAlts+2)
  real :: K2Vel_GD(-1:nAlts+2,1:3)
  real :: K2Temp(-1:nAlts+2)
  real :: K2VertVel(-1:nAlts+2,1:nSpecies)

  real :: K3LogNS(-1:nAlts+2,1:nSpecies)
  real :: K3LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: K3LogRho(-1:nAlts+2)
  real :: K3Vel_GD(-1:nAlts+2,1:3)
  real :: K3Temp(-1:nAlts+2)
  real :: K3VertVel(-1:nAlts+2,1:nSpecies)

  real :: K4LogNS(-1:nAlts+2,1:nSpecies)
  real :: K4LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: K4LogRho(-1:nAlts+2)
  real :: K4Vel_GD(-1:nAlts+2,1:3)
  real :: K4Temp(-1:nAlts+2)
  real :: K4VertVel(-1:nAlts+2,1:nSpecies)

  ! Fill in ghost cells
  call set_vertical_bcs(LogRho,LogNS,Vel_GD,Temp,LogINS,IVel,VertVel)

!!! Set the Original State
  OrigLogNS(-1:nAlts+2,1:nSpecies)  = LogNS(-1:nAlts+2,1:nSpecies)
  OrigLogINS(-1:nAlts+2,1:nIonsAdvect) = LogINS(-1:nAlts+2,1:nIonsAdvect)
  OrigLogRho(-1:nAlts+2) = LogRho(-1:nAlts+2)
  OrigVel_GD(-1:nAlts+2,1:3) = Vel_GD(-1:nAlts+2,1:3)
  OrigTemp(-1:nAlts+2)   = Temp(-1:nAlts+2)
  OrigVertVel(-1:nAlts+2,1:nSpecies) = VertVel(-1:nAlts+2,1:nSpecies)

  NewLogNS = LogNS
  NewLogINS = LogINS
  NewLogRho = LogRho
  NewVel_GD = Vel_GD
  NewTemp = Temp
  NewVertVel = VertVel


  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> stage 1", iproc

  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, &
       NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel)

!!! K1 is the first step in a multi-step RK Scheme
  K1LogNS = (NewLogNS - LogNS)
  K1LogINS = (NewLogINS - LogINS)
  K1LogRho = (NewLogRho - LogRho)
  K1Vel_GD = (NewVel_GD - Vel_GD)
  K1Temp = (NewTemp - Temp)
  K1VertVel = (NewVertVel - VertVel)

!!! Now Produce Updated State based upon 
!!! First Update in RK-4 Method
  UpdatedLogNS  = 0.5*K1LogNS + OrigLogNS
  UpdatedLogINS = 0.5*K1LogINS + OrigLogINS
  UpdatedLogRho = 0.5*K1LogRho + OrigLogRho
  UpdatedVel_GD = 0.5*K1Vel_GD + OrigVel_GD
  UpdatedTemp   = 0.5*K1Temp + OrigTemp
  UpdatedVertVel   = 0.5*K1VertVel + OrigVertVel

  LogNS   = UpdatedLogNS 
  LogINS  = UpdatedLogINS 
  LogRho  = UpdatedLogRho 
  Vel_GD  = UpdatedVel_GD 
  Temp    = UpdatedTemp 
  VertVel = UpdatedVertVel 

  NewLogNS   = UpdatedLogNS 
  NewLogINS  = UpdatedLogINS 
  NewLogRho  = UpdatedLogRho 
  NewVel_GD  = UpdatedVel_GD 
  NewTemp    = UpdatedTemp 
  NewVertVel = UpdatedVertVel 

  call set_vertical_bcs(LogRho, LogNS, Vel_GD, Temp, LogINS, IVel, VertVel)


!!! Begin 2nd Update in RK-4 Method
  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, &
       NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel)

!!! K2 is the second step in a multi-step RK Scheme
  K2LogNS = (NewLogNS - LogNS)
  K2LogINS = (NewLogINS - LogINS)
  K2LogRho = (NewLogRho - LogRho)
  K2Vel_GD = (NewVel_GD - Vel_GD)
  K2Temp = (NewTemp - Temp)
  K2VertVel = (NewVertVel - VertVel)

!!! Now Produce Updated State based upon 
!!! RK Scheme
  UpdatedLogNS  = 0.5*K2LogNS + OrigLogNS
  UpdatedLogINS  = 0.5*K2LogINS + OrigLogINS
  UpdatedLogRho  = 0.5*K2LogRho + OrigLogRho
  UpdatedVel_GD  = 0.5*K2Vel_GD + OrigVel_GD
  UpdatedTemp  = 0.5*K2Temp + OrigTemp
  UpdatedVertVel  = 0.5*K2VertVel  + OrigVertVel

  LogNS   = UpdatedLogNS 
  LogINS  = UpdatedLogINS 
  LogRho  = UpdatedLogRho 
  Vel_GD  = UpdatedVel_GD 
  Temp    = UpdatedTemp 
  VertVel = UpdatedVertVel 

  NewLogNS   = UpdatedLogNS 
  NewLogINS  = UpdatedLogINS 
  NewLogRho  = UpdatedLogRho 
  NewVel_GD  = UpdatedVel_GD 
  NewTemp    = UpdatedTemp 
  NewVertVel = UpdatedVertVel 

  call set_vertical_bcs(LogRho, LogNS, Vel_GD, Temp, LogINS, IVel, VertVel)

!!! Begin 3rd Evaluation of the RK-4 Scheme
  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, &
       NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel)

!!! K3 is the third update step 
  K3LogNS = (NewLogNS - LogNS)
  K3LogINS = (NewLogINS - LogINS)
  K3LogRho = (NewLogRho - LogRho)
  K3Vel_GD = (NewVel_GD - Vel_GD)
  K3Temp = (NewTemp - Temp)
  K3VertVel = (NewVertVel - VertVel)

  UpdatedLogNS  = K3LogNS + OrigLogNS
  UpdatedLogINS  = K3LogINS + OrigLogINS
  UpdatedLogRho  = K3LogRho + OrigLogRho
  UpdatedVel_GD  = K3Vel_GD + OrigVel_GD
  UpdatedTemp  = K3Temp + OrigTemp
  UpdatedVertVel  = K3VertVel  + OrigVertVel

  LogNS   = UpdatedLogNS 
  LogINS  = UpdatedLogINS 
  LogRho  = UpdatedLogRho 
  Vel_GD  = UpdatedVel_GD 
  Temp    = UpdatedTemp 
  VertVel = UpdatedVertVel 

  NewLogNS   = UpdatedLogNS 
  NewLogINS  = UpdatedLogINS 
  NewLogRho  = UpdatedLogRho 
  NewVel_GD  = UpdatedVel_GD 
  NewTemp    = UpdatedTemp 
  NewVertVel = UpdatedVertVel 

  call set_vertical_bcs(LogRho, LogNS, Vel_GD, Temp, LogINS, IVel, VertVel)

!! Begin Final Update Sequence
  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, &
       NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel)

!!! K4 is the third update step 
  K4LogNS = (NewLogNS - LogNS)
  K4LogINS = (NewLogINS - LogINS)
  K4LogRho = (NewLogRho - LogRho)
  K4Vel_GD = (NewVel_GD - Vel_GD)
  K4Temp = (NewTemp - Temp)
  K4VertVel = (NewVertVel - VertVel)

!!! Final Update in RK-4 Method
  UpdatedLogNS  = OrigLogNS + (1.0/6.0)*&
       (K1LogNS + 2.0*K2LogNS + 2.0*K3LogNS + K4LogNS)
  UpdatedLogINS  = OrigLogINS + (1.0/6.0)*&
       (K1LogINS + 2.0*K2LogINS + 2.0*K3LogINS + K4LogINS)
  UpdatedLogRho  = OrigLogRho + (1.0/6.0)*&
       (K1LogRho + 2.0*K2LogRho + 2.0*K3LogRho + K4LogRho)
  UpdatedVel_GD  = OrigVel_GD + (1.0/6.0)*&
       (K1Vel_GD + 2.0*K2Vel_GD + 2.0*K3Vel_GD + K4Vel_GD)
  UpdatedTemp  = OrigTemp + (1.0/6.0)*&
       (K1Temp + 2.0*K2Temp + 2.0*K3Temp + K4Temp)
  UpdatedVertVel  = OrigVertVel + (1.0/6.0)*&
       (K1VertVel + 2.0*K2VertVel + 2.0*K3VertVel + K4VertVel)

  LogNS   = UpdatedLogNS 
  LogINS  = UpdatedLogINS 
  LogRho  = UpdatedLogRho 
  Vel_GD  = UpdatedVel_GD 
  Temp    = UpdatedTemp 
  VertVel = UpdatedVertVel 

  call set_vertical_bcs(LogRho, LogNS, Vel_GD, Temp, LogINS, IVel, VertVel)

  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> vertical bcs 3", iproc

  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) &
       write(*,*) "========> Done with advance_vertical_1d", iproc



end subroutine advance_vertical_1d

!=============================================================================
subroutine advance_vertical_1stage( LogRho, LogNS, Vel_GD, Temp, NewLogRho, NewLogNS, NewVel_GD, NewTemp, &
     LogINS, NewLogINS, IVel, VertVel, NewVertVel)

  ! With fluxes and sources based on LogRho..Temp, update NewLogRho..NewTemp

  use ModGITM, only: &
       Dt, iEast_, iNorth_, iUp_
  use ModPlanet
  use ModSizeGitm
  use ModVertical, only : &
       Heating, EddyCoef_1d, ViscCoef_1d,Centrifugal, Coriolis, &
       MeanMajorMass_1d, Gamma_1d, InvRadialDistance_C, &
       ChemSources_1d, Gravity_G, &
       Altitude_G,Cv_1D, dAlt_C, dAlt_F, Collisions_1d,&
       IonCollisionS_1d
  use ModTime
  use ModInputs
  use ModConstants
  use ModSources, only : EddyCondAdia
  implicit none

  real, intent(in) :: LogRho(-1:nAlts+2)
  real, intent(in) :: LogNS(-1:nAlts+2,nSpecies)
  real, intent(in) :: LogINS(-1:nAlts+2,nIonsAdvect)
  real, intent(in) :: Vel_GD(-1:nAlts+2,3)
  real, intent(in) :: IVel(-1:nAlts+2,3)
  real, intent(in) :: Temp(-1:nAlts+2)
  real, intent(in) :: VertVel(-1:nAlts+2,nSpecies)

  real, intent(inout) :: NewLogRho(-1:nAlts+2)
  real, intent(inout) :: NewLogNS(-1:nAlts+2,nSpecies)
  real, intent(inout) :: NewLogINS(-1:nAlts+2,nIonsAdvect)
  real, intent(inout) :: NewVel_GD(-1:nAlts+2,3)
  real :: NewVel2_G(-1:nAlts+2)
  real, intent(inout) :: NewTemp(-1:nAlts+2)
  real, intent(inout) :: NewVertVel(-1:nAlts+2,nSpecies)
  real :: NS(-1:nAlts+2,nSpecies), Pressure1D(-1:nAlts+2)
  real :: Rho(-1:nAlts+2)

  real :: LogNum(-1:nAlts+2)

  real, dimension(1:nAlts)    :: GradLogRho, DivVel, GradTemp, GradTempKoM, &
       DiffLogRho, DiffTemp, GradTmp, DiffTmp, DiffLogNum, GradLogNum
  real, dimension(1:nAlts,3) :: GradVel_CD, DiffVel_CD

  real, dimension(1:nAlts,nSpecies)    :: GradLogNS, DiffLogNS, &
       GradVertVel, DiffVertVel, DivVertVel
  real, dimension(1:nAlts,nIonsAdvect) :: GradLogINS, DiffLogINS
  real :: NewSumRho, NewLogSumRho, rat, ed

  integer :: iAlt, iSpecies, jSpecies, iDim

  real, dimension(-1:nAlts+2)    :: NT
  real, dimension(-1:nAlts+2)    :: Press, LogPress
  real, dimension(1:nAlts)    :: DiffLogPress, GradLogPress
  real, dimension(1:nAlts,nSpecies)    :: EddyDiffusionVel

  real :: nVel(-1:nAlts+2,1:nSpecies)
  integer :: nFilter, iFilter
  real :: LowFilter

!! WAVEDRAG Heating  Hickey et al [2000]
  real, dimension(1:nAlts)    :: StressHeating

!\
! Parameters Used for the Sponge
! This Sponge is useful to dampen out spurious modes
! oscillating between the bottom and top of the model.
  integer :: nAltsSponge = 12
  real :: kSP, NuSP, AmpSP

!! Conservative Variables and Boundary Conditions
  real ::    RhoS(-1:nAlts+2,1:nSpecies),&
          NewRhoS(-1:nAlts+2,1:nSpecies),&
    AUSMRhoSFluxes(1:nAlts,1:nSpecies)


  real :: NI(-1:nAlts+2,1:nIonsAdvect), &
   AUSMRhoIFluxes(1:nAlts,1:nSpecies)

  real ::    MomentumS(-1:nAlts+2,1:nSpecies),&
          NewMomentumS(-1:nAlts+2,1:nSpecies),&
              Momentum(-1:nAlts+2,1:3),&
           NewMomentum(-1:nAlts+2,1:3),&
     HydroAUSMMomentumSFluxes(1:nAlts,1:nSpecies), &
      HydroAUSMMomentumFluxes(1:nAlts,3), &
          PressureS(-1:nAlts+2,1:nSpecies), &
          NewNS(-1:nAlts+2,1:nSpecies), &
          NewNT(-1:nAlts+2)

  real :: TotalEnergy(-1:nAlts+2),&
       NewTotalEnergy(-1:nAlts+2),&
       AUSMTotalEnergyNumFluxes(1:nAlts), &
       NewPress(-1:nAlts+2), NewRho(-1:nAlts+2)

  real :: InvScaleHeight, MeanGravity, MeanTemp, MeanMass

  real ::   HydroNS(-1:nAlts+2,1:nSpecies),&
          HydroRhoS(-1:nAlts+2,1:nSpecies), &
            HydroNT(-1:nAlts+2),&
     HydroPressureS(-1:nAlts+2,1:nSpecies),&
      DeviationRhoS(-1:nAlts+2,1:nSpecies),&
 DeviationRhoSRatio(-1:nAlts+2,1:nSpecies),&
      HydroPressure(-1:nAlts+2), &
           HydroRho(-1:nAlts+2)

  logical :: SubtractHydrostatic(-1:nAlts+2,1:nSpecies)   
       !!! Determines whether or not we use 

  ! Gravity-related terms
  real, dimension(-1:nAlts+2)    :: RadialDistance_C, &
                                    EffectiveGravity, &
                                    EffectiveGravity_NoCoriolis

  !! Eddy Diffusion Variables
  real, dimension(1:nAlts,nSpecies)    :: GradLogConS
  real, dimension(-1:nAlts+2,nSpecies)    :: ConS, LogConS
  real, dimension(1:nAlts,nSpecies)    :: EddyCoefRatio_1d
  !--------------------------------------------------------------------------
  !!! Turbulent Lapse Rate Contribution
  real, dimension(-1:nAlts+2)    :: LocalEddyHeatFlux
  real, dimension(-1:nAlts+2)    :: LocalLogEddyHeatFlux
  real, dimension(-1:nAlts+2)    :: LocalGradLogEddyHeatFlux
  !--------------------------------------------------------------------------
  ! 4th Order Gradients on a Non-Uniform Mesh (5-point Stencil)
  !--------------------------------------------------------------------------
  real :: h1, h2, h3, h4
  real :: MeshH1, MeshH2, MeshH3, MeshH4
  real :: MeshCoef0, MeshCoef1, &
          MeshCoef2, MeshCoef3, &
          MeshCoef4

  ! Ion Drag Stuff
  real :: Cin
  integer :: iIon
  real :: RhoI(1:nAlts)
  real :: NewRhoI(1:nAlts)
  real :: IS(-1:nAlts+2,nIonsAdvect)

  NS = exp(LogNS)
  IS = exp(LogINS)
  Rho = exp(LogRho)
  LogNum = alog(sum(NS,dim=2))
  nFilter = 10

  do iAlt = -1, nAlts + 2
    RadialDistance_C(iAlt) = 1.0/InvRadialDistance_C(iAlt)
  enddo
  
  if (UseIonAdvection) then
 !   write(*,*) 'UseIonAdvection = ', UseIonAdvection
        RhoI(1:nAlts) = 0.0
     do iIon = 1, nIonsAdvect
        RhoI(1:nAlts) = RhoI(1:nAlts) + &
           MassI(iIon)*IS(1:nAlts,iIon)
     enddo 
 !    do iAlt = 1, nAlts
 !       write(*,*) 'iAlt, IS, RhoI =', iAlt, IS(iAlt,1), RhoI(iAlt)
 !    enddo 
  endif
  
    Rho(-1:nAlts+2) = 0.0
  do iSpecies = 1, nSpecies  
    Rho(-1:nAlts+2) = &
    Rho(-1:nAlts+2) + &
     Mass(iSpecies)*NS(-1:nAlts+2,iSpecies)
  enddo 
  
  NT(-1:nAlts+2) = 0.0
  do iSpecies = 1, nSpecies
     NT(-1:nAlts+2) = NT(-1:nAlts+2) + &
        NS(-1:nAlts+2,iSpecies)
  enddo 


  do iAlt = -1, nAlts + 2
    Press(iAlt) = NT(iAlt)*Boltzmanns_Constant*Temp(iAlt)
    do iSpecies = 1, nSpecies
     !LogConS(iAlt,iSpecies) = alog(NS(iAlt,iSpecies)/NT(iAlt))
     LogConS(iAlt,iSpecies) = alog(Mass(iSpecies)*NS(iAlt,iSpecies)/Rho(iAlt))
    enddo 
  enddo

!! Eddy Heat Flux = Rho*Cp*Ke*(-Gravity/Cp) = (Rho*Gravity)*KE
  do iAlt = -1, nAlts+2 
!    AdiabaticLapseRate(iAlt) = -Gravity_G(iAlt)/Cv_1D(iAlt)
    LocalEddyHeatFlux(iAlt) = Rho(iAlt)*EddyCoef_1d(iAlt)*(-Gravity_G(iAlt))
 LocalLogEddyHeatFlux(iAlt) = alog(LocalEddyHeatFlux(iAlt))
  enddo 

  call calc_rusanov_alts(LogPress ,GradLogPress,  DiffLogPress)
  call calc_rusanov_alts(LogRho ,GradLogRho,  DiffLogRho)
  call calc_rusanov_alts(LogNum ,GradLogNum,  DiffLogNum)
  call calc_rusanov_alts(Temp   ,GradTemp,    DiffTemp)
  do iDim = 1, 3
     call calc_rusanov_alts(Vel_GD(:,iDim), &
          GradVel_CD(:,iDim),DiffVel_CD(:,iDim))
  enddo

  ! Add geometrical correction to gradient and obtain divergence
  DivVel = GradVel_CD(:,iUp_) + &
       2*Vel_GD(1:nAlts,iUp_)*InvRadialDistance_C(1:nAlts)

  do iSpecies=1,nSpecies

     call calc_rusanov_alts(LogNS(:,iSpecies),GradTmp, DiffTmp)
     GradLogNS(:,iSpecies) = GradTmp
     DiffLogNS(:,iSpecies) = DiffTmp

     call calc_rusanov_alts(VertVel(:,iSpecies),GradTmp, DiffTmp)
     GradVertVel(:,iSpecies) = GradTmp
     DiffVertVel(:,iSpecies) = DiffTmp
     DivVertVel(:,iSpecies) = GradVertVel(:,iSpecies) + &
          2*VertVel(1:nAlts,iSpecies)*InvRadialDistance_C(1:nAlts)

  enddo

  do iSpecies=1,nIonsAdvect
     call calc_rusanov_alts(LogINS(:,iSpecies), GradTmp, DiffTmp)
     GradLogINS(:,iSpecies) = GradTmp
     DiffLogINS(:,iSpecies) = DiffTmp
  enddo

  !!! Add the Grad Log Con Variable
  if (UseBoquehoAndBlelly) then
     do iAlt = 1, nAlts
        do iSpecies = 1, nSpecies
            GradLogConS(iAlt,iSpecies) = &
                 -1.0*Gravity_G(iAlt)*&
                 (1.0 -  (MeanMajorMass_1d(iAlt)/Mass(iSpecies)) )
        enddo
     enddo
  else 

!     do iSpecies=1,nSpecies
!        call calc_rusanov_alts(LogConS(:,iSpecies), GradTmp, DiffTmp)
!        GradLogConS(:,iSpecies) = GradTmp
!     enddo

    do iAlt = 1, nAlts

       h1 = dAlt_F(iAlt-1)
       h2 = dAlt_F(iAlt+0)
       h3 = dAlt_F(iAlt+1)
       h4 = dAlt_F(iAlt+2)

       MeshH2 = h2 + h1
       MeshH3 = h3 + h2 + h1
       MeshH4 = h4 + h3 + h2 + h1

       MeshCoef0 = (h2*h3*(h3+h4))/(h1*MeshH2*MeshH3*MeshH4)
       MeshCoef1 = -1.0*(MeshH2*h3*(h3 + h4))/(h1*h2*(h2+h3)*(h2+h3+h4))
       MeshCoef3 = MeshH2*h2*(h4 + h3)/(MeshH3*(h2+h3)*h3*h4) 
       MeshCoef4 = -1.0*MeshH2*h2*h3/(MeshH4*(h2+h3+h4)*(h3+h4)*h4)

       MeshCoef2 = (h2*h3*(h3+h4) + &
                    MeshH2*h3*(h3+h4) - &
                    MeshH2*h2*(h3+h4) - &
                    MeshH2*h2*h3)/&
                    (MeshH2*h2*h3*(h3+h4))

       do iSpecies = 1, nSpecies
        GradLogConS(iAlt,iSpecies) =  &
           MeshCoef0*LogConS(iAlt-2,iSpecies)&
        +  MeshCoef1*LogConS(iAlt-1,iSpecies)&
        +  MeshCoef2*LogConS(iAlt  ,iSpecies)&
        +  MeshCoef3*LogConS(iAlt+1,iSpecies)&
        +  MeshCoef4*LogConS(iAlt+2,iSpecies)
      enddo 
    enddo 

  endif 

!!!!  BEGIN THE HYDROSTATIC BACKGROUND
  HydroNS(-1:nAlts+2,1:nSpecies) = NS(-1:nAlts+2,1:nSpecies)
  HydroNT(-1:nAlts+2) = NT(-1:nAlts+2)

 !!! Establish the Effective Gravity
 do iAlt = -1, nAlts + 2
    EffectiveGravity(iAlt) = &
       Gravity_G(iAlt) + & 
       (Vel_GD(iAlt,iNorth_)**2 + Vel_GD(iAlt,iEast_)**2) &
       *InvRadialDistance_C(iAlt) + &
       Centrifugal/InvRadialDistance_C(iAlt) + &
      Coriolis*Vel_GD(iAlt,iEast_)

    EffectiveGravity_NoCoriolis(iAlt) = &
       Gravity_G(iAlt) + Centrifugal/InvRadialDistance_C(iAlt) 
 enddo

 !!! Establish the Hydrostatic Background Densities
 do iAlt = 1, nAlts + 2
   MeanMass = 0.5*(MeanMajorMass_1d(iAlt-1) + MeanMajorMass_1d(iAlt))
   MeanGravity = 0.5*( EffectiveGravity(iAlt) + EffectiveGravity(iAlt-1) )
   MeanTemp = 0.5*( Temp(iAlt) + Temp(iAlt-1) )
   InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                    (Boltzmanns_Constant*MeanTemp)
   HydroNT(iAlt) = HydroNT(iAlt-1)*(Temp(iAlt-1)/Temp(iAlt))*&
         exp (-1.0*dAlt_F(iAlt)*InvScaleHeight)
 enddo 
 iAlt = -1
 MeanMass = 0.5*( MeanMajorMass_1d(-1) + MeanMajorMass_1d(0))
 MeanGravity = 0.5*( EffectiveGravity(iAlt+1) + EffectiveGravity(iAlt) )
 MeanTemp = 0.5*( Temp(iAlt+1) + Temp(iAlt) )
 InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                 (Boltzmanns_Constant*MeanTemp)
 HydroNT(iAlt) = HydroNT(iAlt+1)*(Temp(iAlt+1)/Temp(iAlt))*&
                 exp(dAlt_F(iAlt)*InvScaleHeight)

!!!! The Old Species Way
 do iSpecies =  1, nSpecies
    do iAlt = 1, nAlts + 2
   
    MeanMass = Mass(iSpecies)
    MeanGravity = 0.5*( EffectiveGravity(iAlt) + EffectiveGravity(iAlt-1) )
    MeanTemp = 0.5*( Temp(iAlt) + Temp(iAlt-1) )
    InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                     (Boltzmanns_Constant*MeanTemp)
    HydroNS(iAlt,iSpecies) = &
          HydroNS(iAlt-1,iSpecies)*(Temp(iAlt-1)/Temp(iAlt))*&
          exp (-1.0*dAlt_F(iAlt)*InvScaleHeight)

    enddo 
 enddo 
 do iSpecies =  1, nSpecies
    iAlt = -1
    MeanMass = 0.5*( MeanMajorMass_1d(-1) + MeanMajorMass_1d(0))
    MeanGravity = 0.5*( EffectiveGravity(iAlt+1) + EffectiveGravity(iAlt) )
    MeanTemp = 0.5*( Temp(iAlt+1) + Temp(iAlt) )
    InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                     (Boltzmanns_Constant*MeanTemp)
    HydroNS(iAlt,iSpecies) = &
              HydroNS(iAlt+1,iSpecies)*(Temp(iAlt+1)/Temp(iAlt))*&
              exp(dAlt_F(iAlt)*InvScaleHeight)

 enddo 

 do iAlt = -1, nAlts + 2
    do iSpecies =  1, nSpecies
      HydroPressureS(iAlt,iSpecies) = &
          HydroNS(iAlt,iSpecies)*Boltzmanns_Constant*Temp(iAlt)
      HydroRhoS(iAlt,iSpecies) = Mass(iSpecies)*HydroNS(iAlt,iSpecies)
    enddo 
      HydroPressure(iAlt) = HydroNT(iAlt)*Boltzmanns_Constant*Temp(iAlt)
           HydroRho(iAlt) = HydroNT(iAlt)*MeanMajorMass_1d(iAlt)
 enddo 

 do iSpecies = 1, nSpecies
    RhoS(-1:nAlts+2,iSpecies) =  &
       Mass(iSpecies)*NS(-1:nAlts+2,iSpecies)

    NewRhoS(-1:nAlts+2,iSpecies) = RhoS(-1:nAlts+2,iSpecies)

    MomentumS(-1:nAlts+2,iSpecies) =  &
       Mass(iSpecies)*NS(-1:nAlts+2,iSpecies)*&
        VertVel(-1:nAlts+2,iSpecies)

    PressureS(-1:nAlts+2,iSpecies) =  &
       NS(-1:nAlts+2,iSpecies)*Temp(-1:nAlts+2)*&
       Boltzmanns_Constant
 enddo 

 do iDim = 1, 3
    Momentum(-1:nAlts+2,iDim) = Rho(-1:nAlts+2)*Vel_GD(-1:nAlts+2,iDim)
 enddo 

!!!! Calculate Deviations between the GITM Fields and the Background State
 DeviationRhoS(-1:nAlts+2,1:nSpecies) = &
   RhoS(-1:nAlts+2,1:nSpecies) - HydroRhoS(-1:nAlts+2,1:nSpecies)

!!! ==========================
 do iAlt = -1, nAlts + 2
  TotalEnergy(iAlt) = &
       Press(iAlt)/(Gamma_1d(iAlt) - 1.0) + &
       0.5*Rho(iAlt)*(Vel_GD(iAlt,iUp_)**2.0 + &
                      Vel_GD(iAlt,iNorth_)**2.0 + &
                      Vel_GD(iAlt,iEast_)**2.0) 
 enddo 

 DeviationRhoSRatio(-1:nAlts+2,1:nSpecies) = & 
           abs(RhoS(-1:nAlts+2,1:nSpecies) - &
          HydroRhoS(-1:nAlts+2,1:nSpecies))/&
               RhoS(-1:nAlts+2,1:nSpecies)

 do iAlt = -1, nAlts + 2
   do iSpecies = 1, nSpecies
     if ( abs(DeviationRhoSRatio(iAlt,iSpecies)) .gt. 1.0) then
         SubtractHydrostatic(iAlt,iSpecies) = .false.
     else
         SubtractHydrostatic(iAlt,iSpecies) = .true.
     endif 
   enddo 
 enddo 

 NewRho = Rho
 NewPress = Press
 NewTotalEnergy = TotalEnergy

 call calc_all_fluxes_hydro(RhoS, PressureS, TotalEnergy, &
                     HydroPressureS, HydroRhoS, &
                     HydroPressure,  HydroRho, AUSMRhoSFluxes,  &
                     HydroAUSMMomentumSFluxes, AUSMTotalEnergyNumFluxes, &
                     HydroAUSMMomentumFluxes, RadialDistance_C, &
                     SubtractHydrostatic, &
                     RhoI, IVel, AUSMRhoIFluxes)

  AmpSP = (1.0/(10.0*Dt))
  kSP = nAltsSponge + 1

  do iAlt = 1,nAlts

     NewLogRho(iAlt) = LogRho(iAlt) - Dt * &
          (DivVel(iAlt) + Vel_GD(iAlt,iUp_) * GradLogRho(iAlt) ) &
          + Dt* DiffLogRho(iAlt)

     do iSpecies=1,nSpecies

        !NewLogNS(iAlt,iSpecies) = LogNS(iAlt,iSpecies) - Dt * &
        !     (DivVertVel(iAlt,iSpecies) + &
        !     VertVel(iAlt,iSpecies) * GradLogNS(iAlt,iSpecies) ) + &
        !      Dt * DiffLogNS(iAlt,iSpecies)

        NewRhoS(iAlt,iSpecies) = RhoS(iAlt,iSpecies) &
               - Dt*(AUSMRhoSFluxes(iAlt,iSpecies))

        NewLogNS(iAlt,iSpecies) = alog( NewRhoS(iAlt,iSpecies)/Mass(iSpecies) )
     enddo

     do iSpecies=1,nIonsAdvect

        NewLogINS(iAlt,iSpecies) = LogINS(iAlt,iSpecies) - Dt * &
             (IVel(iAlt,iUp_) * GradLogINS(iAlt,iSpecies) ) &
             + Dt * DiffLogINS(iAlt,iSpecies)


!        NewRhoI(iAlt,iSpecies) = RhoI(iAlt,iSpecies) &
!               - Dt*(AUSMRhoIFluxes(iAlt,iSpecies))

!        NewLogINS(iAlt,iSpecies) = alog( NewRhoI(iAlt,iSpecies)/MassI(iSpecies) )
     enddo

    enddo !iAlt = 1,nAlts


   !  NewVel_GD(iAlt,iUp_) = 0.0
!
!     if (iAlt >= (nAlts - nAltsSponge)) then
!        NuSP = AmpSP*(1.0 - cos( pi*(kSP - (nAlts - iAlt))/kSP) )
!     else
!        NuSP = 0.0
!     endif
!
!     if (UseDamping) then
!        VertTau(iAlt) = &
!             15 - (1 - exp(-1.0*altitude_G(ialt)/1000.0/40.0))*5.0
!     endif
!
     NewNS  = 0.0
     NewNT  = 0.0
     NewRho = 0.0

     do iAlt = -1, nAlts+2
        do iSpecies = 1, nSpecies
            NewNS(iAlt,iSpecies) = NewRhoS(iAlt,iSpecies)/Mass(iSpecies)

            NewRho(iAlt) = NewRho(iAlt) + &
                     NewRhoS(iAlt,iSpecies)

            NewNT(iAlt) = NewNT(iAlt) + &
                  NewNS(iAlt,iSpecies)
        enddo 
     enddo 

  do iAlt = 1,nAlts

     NewVel_GD(iAlt,iUp_) = 0.0

     if (iAlt >= (nAlts - nAltsSponge)) then
        NuSP = AmpSP*(1.0 - cos( pi*(kSP - (nAlts - iAlt))/kSP) )
     else
        NuSP = 0.0
     endif

     if (UseDamping) then
        VertTau(iAlt) = &
             15 - (1 - exp(-1.0*altitude_G(ialt)/1000.0/40.0))*5.0
     endif

     do iSpecies=1,nSpecies
!! The AUSM Method
           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
                 Dt*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
                 Dt*DeviationRhoS(iAlt,iSpecies)*EffectiveGravity(iAlt) 

           if (SubtractHydrostatic(iAlt,iSpecies) .eq. .false.) then
           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
                 Dt*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
                 Dt*RhoS(iAlt,iSpecies)*EffectiveGravity(iAlt) 
           endif 

           NewMomentumS(iAlt,iSpecies) = NewMomentumS(iAlt,iSpecies) + &
                 Dt*ChemSources_1d(iAlt,iSpecies)*&
                 VertVel(iAlt,iSpecies)*Mass(iSpecies)

           NewVertVel(iAlt,iSpecies) = &
              NewMomentumS(iAlt,iSpecies)/NewRhoS(iAlt,iSpecies) 

        if (UseIonDrag .and. UseIonAdvection) then
            Cin = Dt*IonCollisionS_1d(iAlt,1,iSpecies)*RhoI(iAlt)/&
                    (Mass(iSpecies)*exp(LogNS(iAlt,iSpecies)))

            NewVertVel(iAlt,iSpecies) = &
             (NewVertVel(iAlt,iSpecies) + Cin*IVel(iAlt,iUp_))/(1.0 + Cin)
        endif 

     enddo  ! iSpecies
  enddo ! iAlts


  ! Both Flags set in the Input File
  if (UseNeutralFriction .and. UseNeutralFrictionInSolver) then

           nVel(-1:nAlts+2,1:nSpecies) = NewVertVel(-1:nAlts+2,1:nSpecies)
           call calc_neutral_friction(nVel(1:nAlts,1:nSpecies), &
                                      EddyCoef_1d(1:nAlts), &
                                      NT(1:nAlts), &
                                      NS(1:nAlts,1:nSpecies), &
                                      GradLogConS(1:nAlts,1:nSpecies), &
                                      EddyCoefRatio_1d(1:nAlts,1:nSpecies), &
                                      Temp(1:nAlts), Gravity_G(1:nAlts) )

           NewVertVel(1:nAlts,1:nSpecies) = nVel(1:nAlts,1:nSpecies)
  endif 

  NewVel_GD(-1:nAlts+2,iUp_) = 0.0
  do iAlt = 1, nAlts

     do iSpecies=1,nSpecies

        NewVertVel(iAlt, iSpecies) = max(-MaximumVerticalVelocity, &
             NewVertVel(iAlt, iSpecies))
        NewVertVel(iAlt, iSpecies) = min( MaximumVerticalVelocity, &
             NewVertVel(iAlt, iSpecies))

        NewVel_GD(iAlt,iUp_) = NewVel_GD(iAlt,iUp_) + &
             NewVertVel(iAlt, iSpecies) * &
             (Mass(iSpecies) * NS(iAlt,iSpecies) / Rho(iAlt))

     enddo

  enddo

  StressHeating = 0.0

  if (UseStressHeating) then

    do iAlt = 1, nAlts 

      StressHeating(iAlt) = ViscCoef_1d(iAlt)* &
       (  (  (Gamma_1d(iAlt) - 1.0)/ ( NT(iAlt)*Boltzmanns_Constant) ) * &
           (  &
              (4.0/3.0)*GradVel_CD(iAlt,iUp_)**2 +    &
                        GradVel_CD(iAlt,iNorth_)**2 + &
                        GradVel_CD(iAlt,iEast_)**2    &
           )  )

    enddo

  endif

  do iAlt = 1, nAlts

     ! dVphi/dt = - (V grad V)_phi
     NewVel_GD(iAlt,iEast_) = Vel_GD(iAlt,iEast_) - Dt * &
          Vel_GD(iAlt,iUp_)*GradVel_CD(iAlt,iEast_) &
          + Dt * DiffVel_CD(iAlt,iEast_)

     ! dVtheta/dt = - (V grad V)_theta
     NewVel_GD(iAlt,iNorth_) = Vel_GD(iAlt,iNorth_) - Dt * &
          Vel_GD(iAlt,iUp_)*GradVel_CD(iAlt,iNorth_) &
          + Dt * DiffVel_CD(iAlt,iNorth_)

     if (UseIonDrag .and. UseIonAdvection) then
         Cin = Dt*Collisions_1d(iAlt)*RhoI(iAlt)/Rho(iAlt)
         NewVel_GD(iAlt,iNorth_) = &
           (NewVel_GD(iAlt,iNorth_) + Cin*IVel(iAlt,iNorth_))/(1.0 + Cin)

         NewVel_GD(iAlt,iEast_) = &
           (NewVel_GD(iAlt,iEast_) + Cin*IVel(iAlt,iEast_))/(1.0 + Cin)
     endif 

     ! dT/dt = -(V.grad T + (gamma - 1) T div V +  &
     !        (gamma - 1) * g  * grad (KeH^2  * rho) /rho 

!     if (UseTurbulentCond) then
!        NewTemp(iAlt)   = NewTemp(iAlt) - Dt * &
!             (Vel_GD(iAlt,iUp_)*GradTemp(iAlt) + &
!             (Gamma_1d(iAlt) - 1.0) * Temp(iAlt)*DivVel(iAlt))&
!             + Dt * DiffTemp(iAlt)
!     else
!
!        NewTemp(iAlt)   = Temp(iAlt) - Dt * &
!             (Vel_GD(iAlt,iUp_)*GradTemp(iAlt) + &
!             (Gamma_1d(iAlt) - 1.0) * ( &
!             Temp(iAlt)*DivVel(iAlt))) &
!             + Dt * DiffTemp(iAlt) & 
!             + Dt * StressHeating(iAlt) 
!
!        NewTemp(iAlt)   = NewTemp(iAlt) + &
!             Dt*Vel_GD(iAlt,iUp_)* &
!             ( (Gamma_1d(iAlt) - 1.0)/Gamma_1d(iAlt) )*&
!               Temp(iAlt)*GradLogPress(iAlt)

 
!           NewTemp(iAlt) = NewTemp(iAlt) - Dt*(LocalEddyHeatFlux(iAlt)*&
!              LocalGradLogEddyHeatFlux(iAlt))/(Rho(iAlt)*Cv_1D(iAlt))

!
     ! dT/dt = -(V.grad T + (gamma - 1) T div V +  &
     !        (gamma - 1) * g  * grad (KeH^2  * rho) /rho 

          NewTotalEnergy(iAlt)   = TotalEnergy(iAlt) - &
              Dt*AUSMTotalEnergyNumFluxes(iAlt) + &
              Dt*Rho(iAlt)*Vel_GD(iAlt,iUp_)*EffectiveGravity_NoCoriolis(iAlt) 
 
          NewPress(iAlt) = &
             (NewTotalEnergy(iAlt) - &
              0.5*NewRho(iAlt)*(NewVel_GD(iAlt,iUp_)**2.0 + NewVel_GD(iAlt,iNorth_)**2.0 + &
                  NewVel_GD(iAlt,iEast_)**2.0 ) )*(Gamma_1d(iAlt) - 1.0)

          NewTemp(iAlt) = NewPress(iAlt)/(Boltzmanns_Constant*NewNT(iAlt))

          NewTemp(iAlt) = NewTemp(iAlt) + Dt*StressHeating(iAlt)

          NewTemp(iAlt) = NewTemp(iAlt) + &
            0.25*exp(-1.0*(Altitude_G(iAlt) - Altitude_G(0))/&
            (30.0e+03)) * Dt*DiffTemp(iAlt)

  end do

  do iAlt = 1, nAlts
     NewSumRho    = sum( Mass(1:nSpecies)*exp(NewLogNS(iAlt,1:nSpecies)) )
     NewLogRho(iAlt) = alog(NewSumRho)
  enddo

end subroutine advance_vertical_1stage

!\
! ------------------------------------------------------------
! calc_rusanov
! ------------------------------------------------------------
!/

subroutine calc_rusanov_alts(Var, GradVar, DiffVar)

  use ModSizeGitm
  use ModVertical, only : dAlt_C, cMax
  implicit none

  real, intent(in) :: Var(-1:nAlts+2)
  real, intent(out):: GradVar(1:nAlts), DiffVar(1:nAlts)

  real, dimension(1:nAlts+1) :: VarLeft, VarRight, DiffFlux
  !------------------------------------------------------------

  call calc_facevalues_alts(Var, VarLeft, VarRight)

  ! Gradient based on averaged Left/Right values
  GradVar = 0.5 * &
       (VarLeft(2:nAlts+1)+VarRight(2:nAlts+1) - &
       VarLeft(1:nAlts)-VarRight(1:nAlts))/dAlt_C(1:nAlts)

  ! Rusanov/Lax-Friedrichs diffusive term
  DiffFlux = 0.5 * max(cMax(0:nAlts),cMax(1:nAlts+1)) * (VarRight - VarLeft)

  DiffVar = (DiffFlux(2:nAlts+1) - DiffFlux(1:nAlts))/dAlt_C(1:nAlts)

end subroutine calc_rusanov_alts

!\
! ------------------------------------------------------------
! calc_facevalues_alts
! ------------------------------------------------------------
!/

subroutine calc_facevalues_alts(Var, VarLeft, VarRight)

  use ModVertical, only: dAlt_F, InvDAlt_F
  use ModSizeGITM, only: nAlts
  use ModLimiterGitm

  implicit none
  
  real, intent(in) :: Var(-1:nAlts+2)
  real, intent(out):: VarLeft(1:nAlts+1), VarRight(1:nAlts+1)

  real :: dVarUp, dVarDown, dVarLimited(0:nAlts+1)

  real, parameter :: Factor1=0.6250000 ! 15/24
  real, parameter :: Factor2=0.0416667 !  1/24
  real :: h

  integer :: i

  do i=1,nAlts

     ! 4th order scheme for calculating face values

     h  = InvDAlt_F(i+1)*2.0
     dVarUp   = h*(Factor1*(Var(i+1)-Var(i)  ) - Factor2*(Var(i+2)-Var(i-1)))
     h  = InvDAlt_F(i)*2.0
     dVarDown = h*(Factor1*(Var(i)  -Var(i-1)) - Factor2*(Var(i+1)-Var(i-2)))

!     ! This is Gabor's scheme
!     dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
!     dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)

     dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)

!     write(*,*) dVarUp, dVarDown, dVarLimited(i)

  end do

  i = 0
  dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
  dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)
  dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)

  i = nAlts+1
  dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
  dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)
  dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)

  do i=1,nAlts+1
     VarLeft(i)  = Var(i-1) + 0.5*dVarLimited(i-1) * dAlt_F(i)
     VarRight(i) = Var(i)   - 0.5*dVarLimited(i)   * dAlt_F(i)
  end do

end subroutine calc_facevalues_alts


subroutine calc_all_fluxes_hydro(RhoS, PressureS, Energy, &
           HydroPressureS, HydroRhoS, HydroPressure, HydroRho, &
           RhoSFlux, MomentumSFlux, EnergyFluxes, &
           MomentumFluxes, RadDist, SubtractHydrostatic, &
           RhoI, IVel, RhoIFlux)



  use ModSizeGitm
  use ModVertical, only : dAlt_C, cMax, VertVel, Gamma_1D, &
                          LogRho, Vel_GD, MeanMajorMass_1d, &
                          Temp, Altitude_G, TotalRhoFluxes_1d


  use ModPlanet, only : nSpecies, nIonsAdvect, Mass, RBody, &
                        iN2_, iO2_,iO_3P_, iNO_, iN_4S_
  use ModGITM, only : Dt,iUp_, iEast_, iNorth_
  use ModConstants, only : Boltzmanns_Constant

  implicit none

  real, intent(in) :: RhoS(-1:nAlts+2, 1:nSpecies), PressureS(-1:nAlts+2,1:nSpecies)
  real, intent(in) :: HydroRhoS(-1:nAlts+2, 1:nSpecies), HydroPressureS(-1:nAlts+2,1:nSpecies)
  real, intent(in) :: HydroRho(-1:nAlts+2), HydroPressure(-1:nAlts+2)
  real, intent(in) :: Energy(-1:nAlts+2)
  real, intent(out):: RhoSFlux(1:nAlts,1:nSpecies), MomentumSFlux(1:nAlts,1:nSpecies)
  real, intent(out) :: EnergyFluxes(1:nAlts)
  real, intent(out) :: MomentumFluxes(1:nAlts,3)
  real, intent(in) :: RadDist(-1:nAlts+2)
  logical, intent(in) :: SubtractHydrostatic(-1:nAlts+2,1:nSpecies)
  real, intent(in) :: RhoI(-1:nAlts+2, 1:nIonsAdvect)
  real, intent(in) :: IVel(-1:nAlts+2, 1:3)
  real, intent(out):: RhoIFlux(1:nAlts,1:nIonsAdvect)

  real, dimension(1:nAlts,1:nSpecies) :: RhoSLeft_M12, RhoSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: RhoSLeft_P12, RhoSRight_P12

  real, dimension(-1:nAlts+2, 1:nSpecies) :: LogRhoS
  real, dimension(-1:nAlts+2, 1:nSpecies) :: LogPS

  real, dimension(1:nAlts,1:nSpecies) :: LogRhoSLeft_M12, LogRhoSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogRhoSLeft_P12, LogRhoSRight_P12

  real, dimension( 1:nAlts  ,1:nIonsAdvect) :: RhoILeft_M12, RhoIRight_M12
  real, dimension( 1:nAlts  ,1:nIonsAdvect) :: RhoILeft_P12, RhoIRight_P12
  real, dimension(-1:nAlts+2,1:nIonsAdvect) :: LogRhoI
  real, dimension( 1:nAlts  ,1:nIonsAdvect) :: LogRhoILeft_M12, LogRhoIRight_M12
  real, dimension( 1:nAlts  ,1:nIonsAdvect) :: LogRhoILeft_P12, LogRhoIRight_P12


  real, dimension(1:nAlts,1:nSpecies) :: PressureSLeft_M12, PressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: PressureSLeft_P12, PressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: LogPressureSLeft_M12, LogPressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogPressureSLeft_P12, LogPressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: VelLeft_M12, VelRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: VelLeft_P12, VelRight_P12

  real, dimension(1:nAlts,3) :: VelGDLeft_M12, VelGDRight_M12
  real, dimension(1:nAlts,3) :: VelGDLeft_P12, VelGDRight_P12

  real, dimension(1:nAlts,3) :: IVelLeft_M12, IVelRight_M12
  real, dimension(1:nAlts,3) :: IVelLeft_P12, IVelRight_P12

  real, dimension(1:nAlts) :: PLeft_M12, PRight_M12
  real, dimension(1:nAlts) :: PLeft_P12, PRight_P12

  real, dimension(1:nAlts) :: GammaLeft_M12, GammaRight_M12
  real, dimension(1:nAlts) :: GammaLeft_P12, GammaRight_P12

  real, dimension(1:nAlts) :: ELeft_M12, ERight_M12
  real, dimension(1:nAlts) :: ELeft_P12, ERight_P12

  real, dimension(1:nAlts) :: RhoLeft_M12, RhoRight_M12
  real, dimension(1:nAlts) :: RhoLeft_P12, RhoRight_P12

  real, dimension(1:nAlts) :: CSLeft_M12, CSRight_M12
  real, dimension(1:nAlts) :: CSLeft_P12, CSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: RhoSFlux_M12, RhoSFlux_P12
  real, dimension(1:nAlts,1:nSpecies) :: MomentumSFlux_M12, MomentumSFlux_P12
  real, dimension(1:nAlts,3) :: Momentum_M12, Momentum_P12
  real, dimension(1:nAlts,1:nIonsAdvect) :: RhoIFlux_M12, RhoIFlux_P12

  real, dimension(1:nAlts) :: EnergyFlux_M12, EnergyFlux_P12

!!! Hydrostatic Variables
  real, dimension(-1:nAlts+2,1:nSpecies) :: LogHydroPressureS

!  real, dimension(-1:nAlts+2,1:nSpecies) :: LogHydroRhoS

  real, dimension(1:nAlts,1:nSpecies) :: LogHydroPressureSLeft_M12, LogHydroPressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogHydroPressureSLeft_P12, LogHydroPressureSRight_P12


!  real, dimension(1:nAlts,1:nSpecies) :: LogHydroRhoSLeft_M12, LogHydroRhoSRight_M12
!  real, dimension(1:nAlts,1:nSpecies) :: LogHydroRhoSLeft_P12, LogHydroRhoSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: HydroPressureSLeft_M12, HydroPressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: HydroPressureSLeft_P12, HydroPressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: MeanHydroPressureS_M12
  real, dimension(1:nAlts,1:nSpecies) :: MeanHydroPressureS_P12


!  real, dimension(1:nAlts,1:nSpecies) :: HydroRhoSLeft_M12, HydroRhoSRight_M12
!  real, dimension(1:nAlts,1:nSpecies) :: HydroRhoSLeft_P12, HydroRhoSRight_P12



!!!! ============ Mean Hydrostatic Variables (For Energy Calculation) ======= 
!
!  real, dimension(-1:nAlts+2) :: LogHydroPressure
!  real, dimension(-1:nAlts+2) :: LogHydroRho
!
!  real, dimension(1:nAlts) :: LogHydroPressureLeft_M12, LogHydroPressureRight_M12
!  real, dimension(1:nAlts) :: LogHydroPressureLeft_P12, LogHydroPressureRight_P12
!
!  real, dimension(1:nAlts) :: LogHydroRhoLeft_M12, LogHydroRhoRight_M12
!  real, dimension(1:nAlts) :: LogHydroRhoLeft_P12, LogHydroRhoRight_P12
!
!  real, dimension(1:nAlts) :: HydroPressureLeft_M12, HydroPressureRight_M12
!  real, dimension(1:nAlts) :: HydroPressureLeft_P12, HydroPressureRight_P12
!  real, dimension(1:nAlts) :: MeanHydroPressure_M12, MeanHydroPressure_P12
!
!  real, dimension(1:nAlts) :: HydroRhoLeft_M12, HydroRhoRight_M12
!  real, dimension(1:nAlts) :: HydroRhoLeft_P12, HydroRhoRight_P12
  real :: SubCs
  integer :: iSpecies, iAlt, iDim
  !------------------------------------------------------------

  ! ==================== AUSM Flux Variables

  real, dimension( 1:nAlts,1:nSpecies) :: NumericalVelocity_P12, NumericalVelocity_M12
  real, dimension( 1:nAlts,1:nSpecies) :: NumericalPressure_P12, NumericalPressure_M12   

  real, dimension( 1:nAlts) :: BulkNumericalVelocity_P12, BulkNumericalVelocity_M12    
  real, dimension( 1:nAlts) :: BulkIVel_P12, BulkIVel_M12    
  real, dimension( 1:nAlts) :: HorizBulkNumericalVelocity_P12, &
                               HorizBulkNumericalVelocity_M12    
  real, dimension( 1:nAlts) :: MeanCS_P12, MeanCS_M12    ! Interface velocities
  real, dimension( 1:nAlts, 1:nSpecies) :: MeanPressureS_P12, MeanPressureS_M12    
  real, dimension( 1:nAlts, 1:nSpecies) :: MeanRhoS_P12, MeanRhoS_M12    

!  real, dimension( 1:nAlts) :: MeanRho_P12, MeanRho_M12    ! Interface velocities
  real :: Kp(1:nSpecies), Ku(1:nAlts,1:nSpecies)
  real :: LiouKp, LiouKu

  real :: LiouKpS(1:nAlts,1:nSpecies), LiouKuS(1:nAlts,1:nSpecies)
  real :: MaxKpS(1:nAlts,1:nSpecies), MaxKuS(1:nAlts,1:nSpecies)
  real :: MinKpS(1:nAlts,1:nSpecies), MinKuS(1:nAlts,1:nSpecies)
  real :: KpWidth, KpAltMidPoint
  integer :: AltIndex

  real, dimension( 1:nAlts) :: LeftRadius, RightRadius    
  real, dimension( 1:nAlts) :: AreaFunction_P12, AreaFunction_M12    
  real, dimension( 1:nAlts) :: LocalCellVolume

!!!!!! ============================  Liou Stuff =======================================
  real, dimension(1:nAlts) :: LiouCSLeft_M12, LiouCSRight_M12
  real, dimension(1:nAlts) :: LiouCSLeft_P12, LiouCSRight_P12

  real, dimension(1:nAlts) :: LiouEnthalpyLeft_M12, LiouEnthalpyRight_M12
  real, dimension(1:nAlts) :: LiouEnthalpyLeft_P12, LiouEnthalpyRight_P12

  real, dimension(1:nAlts) :: InterfaceCS_M12, InterfaceCS_P12

  real, dimension(1:nAlts,1:nSpecies) :: MLeft_M12, MRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: MLeft_P12, MRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: M2Bar_M12, M2Bar_P12
  real, dimension(1:nAlts,1:nSpecies) :: M2Zero_M12, M2Zero_P12

  real, dimension(1:nAlts,1:nSpecies) :: MZero_M12, MZero_P12
  real:: MInf, LiouBeta
  real, dimension(1:nAlts,1:nSpecies):: ModifiedZeta

  real, dimension(1:nAlts,1:nSpecies) :: FA_M12, FA_P12

!!! Polynomial Mach Functions

!!! First Order Polynomial
  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Left_M12, MF1N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Right_M12, MF1N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Left_P12, MF1N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Right_P12, MF1N_Right_P12

!!!! 2nd Order Polynomial
  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Left_M12, MF2N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Right_M12, MF2N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Left_P12, MF2N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Right_P12, MF2N_Right_P12

!!!! 4th Order Polynomial
  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Left_M12, MF4N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Right_M12, MF4N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Left_P12, MF4N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Right_P12, MF4N_Right_P12

!!!! Pressure Mach Number
  real, dimension(1:nAlts,1:nSpecies) :: MPress_M12, MPress_P12

!!!! Interface Mach Number
  real, dimension(1:nAlts,1:nSpecies) :: InterfaceMach_M12, InterfaceMach_P12

  real, dimension(1:nAlts,1:nSpecies) :: LiouNumericalVelocity_M12, &
                                         LiouNumericalVelocity_P12

!!! Extract Mean Atmosphere Values

  real :: LogKpS(1:nAlts,1:nSpecies), LogKuS(1:nAlts,1:nSpecies)
  real :: LogMinKpS(1:nAlts,1:nSpecies), LogMinKuS(1:nAlts,1:nSpecies)
  real :: LogMaxKpS(1:nAlts,1:nSpecies), LogMaxKuS(1:nAlts,1:nSpecies)

! call report("AUSM_Fluxes",5)
! call start_timing("AUSM_Fluxes")

 MInf = 1.0e-19
 LiouBeta = 1.0/8.0

 LiouKp = 1.0e-09
 LiouKpS(1:nAlts,1:nSpecies) = 1.0e-09

 LogRhoS(-1:nAlts+2,1:nSpecies) = alog(RhoS(-1:nAlts+2,1:nSpecies))
 LogPS(-1:nAlts+2,1:nSpecies) = alog(PressureS(-1:nAlts+2,1:nSpecies))

 !LogHydroRhoS(-1:nAlts+2,1:nSpecies) = alog(HydroRhoS(-1:nAlts+2,1:nSpecies))
 LogHydroPressureS(-1:nAlts+2,1:nSpecies) = alog(HydroPressureS(-1:nAlts+2,1:nSpecies))

 !LogHydroRho(-1:nAlts+2) = alog(HydroRho(-1:nAlts+2))
 !LogHydroPressure(-1:nAlts+2) = alog(HydroPressure(-1:nAlts+2))

 LogRhoI(-1:nAlts+2,1:nIonsAdvect) = alog(RhoI(-1:nAlts+2,1:nIonsAdvect))

 Kp(1:nSpecies) = 0.10             !! Ullrich et al. [2011]

 Ku(1:nAlts,1:nSpecies) = 2.0             !! Ullrich et al. [2011]

  LiouKu = 2.00
  LiouKp = 2.00

!!! 1-D Settings
  MinKuS(1:nAlts,1:nSpecies) = 1.00
  MaxKuS(1:nAlts,1:nSpecies) = 1.00
!

  MinKpS(1:nAlts,1:nSpecies) = 1.0e-09
  MaxKpS(1:nAlts,1:nSpecies) = 1.0e-03


! iN2_
!! Need the two key photochemical species
!! to have more diffusive fluxes

  MinKpS(1:nAlts,iNO_) = 1.0e-02
  MaxKpS(1:nAlts,iNO_) = 5.0e-02
 

  MinKpS(1:nAlts,iO_3P_) = 2.0e-02
  MaxKpS(1:nAlts,iO_3P_) = 2.0e-02


  LogMaxKuS = alog(MaxKuS)
  LogMinKuS = alog(MinKuS)

  LogMaxKpS = alog(MaxKpS)
  LogMinKpS = alog(MinKpS)


!!! Version on 01/23/2013 that looked (OK), but had choppy winds
   KpWidth = 15.0e+03
   KpAltMidPoint = 160.0e+03
 
  do iAlt = 1, nAlts
     do iSpecies = 1, nSpecies
         LogKpS(iAlt,iSpecies) = LogMinKpS(iAlt,iSpecies) +  &
               0.5*(LogMaxKpS(iAlt,iSpecies) - LogMinKpS(iAlt,iSpecies))*&
               ( 1.0 + tanh(  (Altitude_G(iAlt) - KpAltMidPoint)/KpWidth ) )

         LogKuS(iAlt,iSpecies) = LogMinKuS(iAlt,iSpecies) +  &
               0.5*(LogMaxKuS(iAlt,iSpecies) - LogMinKuS(iAlt,iSpecies))*&
               ( 1.0 + tanh(  (Altitude_G(iAlt) - KpAltMidPoint)/KpWidth ) )

        LiouKpS(iAlt,iSpecies) = exp(LogKpS(iAlt,iSpecies))
             Ku(iAlt,iSpecies) = exp(LogKuS(iAlt,iSpecies))
     enddo 
  enddo 

!!!! Grab the left and right states of the Variables
!!!!  on boh Interfaces (P12 = +1/2 and M12 = -1/2)
    do iSpecies = 1, nSpecies
          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogRhoS(-1:nAlts+2,iSpecies), &
                           LogRhoSLeft_M12( 1:nAlts  ,iSpecies), &
                          LogRhoSRight_M12( 1:nAlts  ,iSpecies), &
                           LogRhoSLeft_P12( 1:nAlts  ,iSpecies), &
                          LogRhoSRight_P12( 1:nAlts  ,iSpecies) )

           RhoSLeft_M12(:,iSpecies) = exp( LogRhoSLeft_M12(:,iSpecies)) 
          RhoSRight_M12(:,iSpecies) = exp(LogRhoSRight_M12(:,iSpecies)) 

           RhoSLeft_P12(:,iSpecies) = exp( LogRhoSLeft_P12(:,iSpecies)) 
          RhoSRight_P12(:,iSpecies) = exp(LogRhoSRight_P12(:,iSpecies)) 

    enddo 

    do iSpecies = 1, nIonsAdvect
          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogRhoI(-1:nAlts+2,iSpecies), &
                           LogRhoILeft_M12( 1:nAlts  ,iSpecies), &
                          LogRhoIRight_M12( 1:nAlts  ,iSpecies), &
                           LogRhoILeft_P12( 1:nAlts  ,iSpecies), &
                          LogRhoIRight_P12( 1:nAlts  ,iSpecies) )

           RhoILeft_M12(:,iSpecies) = exp( LogRhoILeft_M12(:,iSpecies)) 
          RhoIRight_M12(:,iSpecies) = exp(LogRhoIRight_M12(:,iSpecies)) 

           RhoILeft_P12(:,iSpecies) = exp( LogRhoILeft_P12(:,iSpecies)) 
          RhoIRight_P12(:,iSpecies) = exp(LogRhoIRight_P12(:,iSpecies)) 
    enddo 

!
!    do iSpecies = 1, nSpecies
!          !! Calculate the Left and Right Faces of the RhoS 
!           call calc_kt_facevalues(LogHydroRhoS(-1:nAlts+2,iSpecies), &
!                           LogHydroRhoSLeft_M12( 1:nAlts  ,iSpecies), &
!                          LogHydroRhoSRight_M12( 1:nAlts  ,iSpecies), &
!                           LogHydroRhoSLeft_P12( 1:nAlts  ,iSpecies), &
!                          LogHydroRhoSRight_P12( 1:nAlts  ,iSpecies) )
!
!           HydroRhoSLeft_M12(:,iSpecies) = exp( LogHydroRhoSLeft_M12(:,iSpecies)) 
!          HydroRhoSRight_M12(:,iSpecies) = exp(LogHydroRhoSRight_M12(:,iSpecies)) 
!
!           HydroRhoSLeft_P12(:,iSpecies) = exp( LogHydroRhoSLeft_P12(:,iSpecies)) 
!          HydroRhoSRight_P12(:,iSpecies) = exp(LogHydroRhoSRight_P12(:,iSpecies)) 
!
!    enddo 

!
!          !! Calculate the Left and Right Faces of the RhoS 
!           call calc_kt_facevalues(LogHydroRho(-1:nAlts+2), &
!                              LogHydroRhoLeft_M12(1:nAlts), &
!                             LogHydroRhoRight_M12(1:nAlts), &
!                              LogHydroRhoLeft_P12(1:nAlts), &
!                             LogHydroRhoRight_P12(1:nAlts) )
!
!           HydroRhoLeft_M12(:) = exp( LogHydroRhoLeft_M12(:)) 
!          HydroRhoRight_M12(:) = exp(LogHydroRhoRight_M12(:)) 
!
!           HydroRhoLeft_P12(:) = exp( LogHydroRhoLeft_P12(:)) 
!          HydroRhoRight_P12(:) = exp(LogHydroRhoRight_P12(:)) 
!
!  


    do iSpecies = 1, nSpecies
          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogHydroPressureS(-1:nAlts+2,iSpecies), &
                              LogHydroPressureSLeft_M12(1:nAlts,iSpecies), &
                              LogHydroPressureSRight_M12(1:nAlts,iSpecies), &
                               LogHydroPressureSLeft_P12(1:nAlts,iSpecies), &
                              LogHydroPressureSRight_P12(1:nAlts,iSpecies) )

           HydroPressureSLeft_M12(:,iSpecies) = &
                 exp( LogHydroPressureSLeft_M12(:,iSpecies)) 
          HydroPressureSRight_M12(:,iSpecies) = &
                 exp(LogHydroPressureSRight_M12(:,iSpecies)) 

           HydroPressureSLeft_P12(:,iSpecies) = &
                 exp( LogHydroPressureSLeft_P12(:,iSpecies)) 
          HydroPressureSRight_P12(:,iSpecies) = &
                 exp(LogHydroPressureSRight_P12(:,iSpecies)) 

    enddo 

!           call calc_kt_facevalues(LogHydroPressure(-1:nAlts+2), &
!                               LogHydroPressureLeft_M12(1:nAlts), &
!                              LogHydroPressureRight_M12(1:nAlts), &
!                               LogHydroPressureLeft_P12(1:nAlts), &
!                              LogHydroPressureRight_P12(1:nAlts) )
!
!           HydroPressureLeft_M12(:) = exp( LogHydroPressureLeft_M12(:)) 
!          HydroPressureRight_M12(:) = exp(LogHydroPressureRight_M12(:)) 
!
!           HydroPressureLeft_P12(:) = exp( LogHydroPressureLeft_P12(:)) 
!          HydroPressureRight_P12(:) = exp(LogHydroPressureRight_P12(:)) 





   do iSpecies = 1, nSpecies
         !! Calculate the Left and Right Faces of the PressureS
          call calc_kt_facevalues(LogPS(:,iSpecies), &
                   LogPressureSLeft_M12(:,iSpecies), LogPressureSRight_M12(:,iSpecies), &
                   LogPressureSLeft_P12(:,iSpecies), LogPressureSRight_P12(:,iSpecies) )

           PressureSLeft_M12(:,iSpecies) = exp( LogPressureSLeft_M12(:,iSpecies)) 
          PressureSRight_M12(:,iSpecies) = exp(LogPressureSRight_M12(:,iSpecies)) 

           PressureSLeft_P12(:,iSpecies) = exp( LogPressureSLeft_P12(:,iSpecies)) 
          PressureSRight_P12(:,iSpecies) = exp(LogPressureSRight_P12(:,iSpecies)) 

   enddo 



   do iSpecies = 1, nSpecies
         !! Calculate the Left and Right Faces of the Var (Rho) 
          call calc_kt_facevalues(VertVel(:,iSpecies), &
                              VelLeft_M12(:,iSpecies), VelRight_M12(:,iSpecies), &
                              VelLeft_P12(:,iSpecies), VelRight_P12(:,iSpecies) )
   enddo 



           RhoLeft_M12(:) = 0.0
           RhoRight_M12(:) = 0.0
 
           RhoLeft_P12(:) = 0.0
           RhoRight_P12(:) = 0.0

           do iSpecies = 1, nSpecies
              RhoLeft_M12(1:nAlts) = RhoLeft_M12(1:nAlts) + &
                                    RhoSLeft_M12(1:nAlts,iSpecies)
              RhoRight_M12(1:nAlts) = RhoRight_M12(1:nAlts) + &
                                     RhoSRight_M12(1:nAlts,iSpecies)

              RhoLeft_P12(1:nAlts) = RhoLeft_P12(1:nAlts) + &
                                    RhoSLeft_P12(1:nAlts,iSpecies)
              RhoRight_P12(1:nAlts) = RhoRight_P12(1:nAlts) + &
                                     RhoSRight_P12(1:nAlts,iSpecies)
           enddo 
 


           PLeft_M12(:) = 0.0
           PRight_M12(:) = 0.0
 
           PLeft_P12(:) = 0.0
           PRight_P12(:) = 0.0

           do iSpecies = 1, nSpecies
              PLeft_M12(1:nAlts) = PLeft_M12(1:nAlts) + &
                           PressureSLeft_M12(1:nAlts,iSpecies)
              PRight_M12(1:nAlts) = PRight_M12(1:nAlts) + &
                            PressureSRight_M12(1:nAlts,iSpecies)

              PLeft_P12(1:nAlts) = PLeft_P12(1:nAlts) + &
                           PressureSLeft_P12(1:nAlts,iSpecies)
              PRight_P12(1:nAlts) = PRight_P12(1:nAlts) + &
                            PressureSRight_P12(1:nAlts,iSpecies)
           enddo 

      do iDim = 1, 3
         !! Calculate the Left and Right Faces of the Var (Rho) 
          call calc_kt_facevalues(Vel_GD(:,iDim), &
                           VelGDLeft_M12(:,iDim), &
                          VelGDRight_M12(:,iDim), &
                           VelGDLeft_P12(:,iDim), &
                          VelGDRight_P12(:,iDim) )
      enddo 


       VelGDLeft_M12(:,iUp_) = 0.0
       VelGDRight_M12(:,iUp_) = 0.0

       VelGDLeft_P12(:,iUp_) = 0.0
       VelGDRight_P12(:,iUp_) = 0.0

       do iSpecies = 1, nSpecies

            VelGDLeft_M12(1:nAlts,iUp_) = &
                     VelGDLeft_M12(1:nAlts,iUp_) + &
                     RhoSLeft_M12(1:nAlts,iSpecies)*&
                     VelLeft_M12(1:nAlts,iSpecies)/RhoLeft_M12(1:nAlts)
            VelGDRight_M12(1:nAlts,iUp_) = &
                     VelGDRight_M12(1:nAlts,iUp_) + &
                     RhoSRight_M12(1:nAlts,iSpecies)*&
                     VelRight_M12(1:nAlts,iSpecies)/RhoRight_M12(1:nAlts)

            VelGDLeft_P12(1:nAlts,iUp_) = &
                     VelGDLeft_P12(1:nAlts,iUp_) + &
                     RhoSLeft_P12(1:nAlts,iSpecies)*&
                     VelLeft_P12(1:nAlts,iSpecies)/RhoLeft_P12(1:nAlts)
            VelGDRight_P12(1:nAlts,iUp_) = &
                     VelGDRight_P12(1:nAlts,iUp_) + &
                     RhoSRight_P12(1:nAlts,iSpecies)*&
                     VelRight_P12(1:nAlts,iSpecies)/RhoRight_P12(1:nAlts)
       enddo 

    do iDim = 1, 3
         !! Calculate the Left and Right Faces of the Var (Rho) 
          call calc_kt_facevalues(IVel(:,iDim), &
                           IVelLeft_M12(:,iDim), &
                          IVelRight_M12(:,iDim), &
                           IVelLeft_P12(:,iDim), &
                          IVelRight_P12(:,iDim) )
    enddo 

        !! Calculate the Left and Right Faces of the Pressure 
    call calc_kt_facevalues(Gamma_1d(:), GammaLeft_M12(:), GammaRight_M12(:), &
                                         GammaLeft_P12(:), GammaRight_P12(:) )



    do iAlt = 1, nAlts
!        ELeft_M12(iAlt) = &
!            ( 1.0/(GammaLeft_M12(iAlt) - 1.0))*PLeft_M12(iAlt) 
!
!        ERight_M12(iAlt) = &
!            ( 1.0/(GammaRight_M12(iAlt) - 1.0))*PRight_M12(iAlt) 
!
!        ELeft_P12(iAlt) = &
!            ( 1.0/(GammaLeft_P12(iAlt) - 1.0))*PLeft_P12(iAlt) 
!
!        ERight_P12(iAlt) = &
!            ( 1.0/(GammaRight_P12(iAlt) - 1.0))*PRight_P12(iAlt) 

!!!! ============= Bulk Values

             ELeft_M12(iAlt) = &
                 ( 1.0/(GammaLeft_M12(iAlt) - 1.0))*PLeft_M12(iAlt) + &
                   0.5*RhoLeft_M12(iAlt)*&
                  (VelGDLeft_M12(iAlt,iUp_)**2.0 + VelGDLeft_M12(iAlt,iEast_)**2.0 + &
                   VelGDLeft_M12(iAlt,iNorth_)**2.0)

             ERight_M12(iAlt) = &
                 ( 1.0/(GammaRight_M12(iAlt) - 1.0))*PRight_M12(iAlt) + &
                   0.5*RhoRight_M12(iAlt)*&
                  (VelGDRight_M12(iAlt,iUp_)**2.0 + VelGDRight_M12(iAlt,iEast_)**2.0 + &
                   VelGDRight_M12(iAlt,iNorth_)**2.0)

             ELeft_P12(iAlt) = &
                 ( 1.0/(GammaLeft_P12(iAlt) - 1.0))*PLeft_P12(iAlt) + &
                   0.5*RhoLeft_P12(iAlt)* &
                  (VelGDLeft_P12(iAlt,iUp_)**2.0 + VelGDLeft_P12(iAlt,iEast_)**2.0 + &
                   VelGDLeft_P12(iAlt,iNorth_)**2.0)

             ERight_P12(iAlt) = &
                 ( 1.0/(GammaRight_P12(iAlt) - 1.0))*PRight_P12(iAlt) + &
                   0.5*RhoRight_P12(iAlt)* &
                  (VelGDRight_P12(iAlt,iUp_)**2.0 + VelGDRight_P12(iAlt,iEast_)**2.0 + &
                   VelGDRight_P12(iAlt,iNorth_)**2.0)
    enddo 


!!!! Liou et al. [2006] suggest using the Enthalpy for the numerical speed of sound.
!!!! Calculate the Enthalpy at the cell faces here.
    do iAlt = 1, nAlts 
       LiouEnthalpyLeft_M12(iAlt) = &
            0.5*(VelGDLeft_M12(iAlt,iUp_)**2.0 + VelGDLeft_M12(iAlt,iEast_)**2.0 + &
                 VelGDLeft_M12(iAlt,iNorth_)**2.0) + &
            (GammaLeft_M12(iAlt)/(GammaLeft_M12(iAlt) - 1.0))*&
            PLeft_M12(iAlt)/RhoLeft_M12(iAlt)

       LiouEnthalpyRight_M12(iAlt) = &
            0.5*(VelGDRight_M12(iAlt,iUp_)**2.0 + VelGDRight_M12(iAlt,iEast_)**2.0 + &
                 VelGDRight_M12(iAlt,iNorth_)**2.0) + &
            (GammaRight_M12(iAlt)/(GammaRight_M12(iAlt) - 1.0))*&
            PRight_M12(iAlt)/RhoRight_M12(iAlt)

       LiouEnthalpyLeft_P12(iAlt) = &
            0.5*(VelGDLeft_P12(iAlt,iUp_)**2.0 + VelGDLeft_P12(iAlt,iEast_)**2.0 + &
                 VelGDLeft_P12(iAlt,iNorth_)**2.0) + &
            (GammaLeft_P12(iAlt)/(GammaLeft_P12(iAlt) - 1.0))*&
            PLeft_P12(iAlt)/RhoLeft_P12(iAlt)

       LiouEnthalpyRight_P12(iAlt) = &
            0.5*(VelGDRight_P12(iAlt,iUp_)**2.0 + VelGDRight_P12(iAlt,iEast_)**2.0 + &
                 VelGDRight_P12(iAlt,iNorth_)**2.0) + &
            (GammaRight_P12(iAlt)/(GammaRight_P12(iAlt) - 1.0))*&
            PRight_P12(iAlt)/RhoRight_P12(iAlt)

    enddo 

!!! Liou Methodology

   do iAlt = 1, nAlts
         SubCs = &
           sqrt(2.0*( (GammaLeft_M12(iAlt) - 1.0 )/(GammaLeft_M12(iAlt) + 1.0)) *&
           LiouEnthalpyLeft_M12(iAlt) )
         LiouCSLeft_M12(iAlt) = (SubCs**2.0)/max(SubCs, VelGDLeft_M12(iAlt,iUp_))

         SubCs = &
           sqrt(2.0*( (GammaRight_M12(iAlt) - 1.0 )/(GammaRight_M12(iAlt) + 1.0)) *&
           LiouEnthalpyRight_M12(iAlt) )
         LiouCSRight_M12(iAlt) = (SubCs**2.0)/max(SubCs, -1.0*VelGDRight_M12(iAlt,iUp_))

         InterfaceCS_M12(iAlt) = min(LiouCSLeft_M12(iAlt), LiouCSRight_M12(iAlt))


         SubCs = &
            sqrt(2.0*( (GammaLeft_P12(iAlt) - 1.0 )/(GammaLeft_P12(iAlt) + 1.0)) *&
            LiouEnthalpyLeft_P12(iAlt) )
         LiouCSLeft_P12(iAlt) = (SubCs**2.0)/max(SubCs, VelGDLeft_P12(iAlt,iUp_))

         SubCs = &
            sqrt(2.0*( (GammaRight_P12(iAlt) - 1.0 )/(GammaRight_P12(iAlt) + 1.0)) *&
            LiouEnthalpyRight_P12(iAlt) )
         LiouCSRight_P12(iAlt) = (SubCs**2.0)/max(SubCs, -1.0*VelGDRight_P12(iAlt,iUp_))

         InterfaceCS_P12(iAlt) = min(LiouCSLeft_P12(iAlt), LiouCSRight_P12(iAlt))
   enddo 

  
  MeanPressureS_P12(1:nAlts,1:nSpecies) = &
        0.5*(PressureSLeft_P12(1:nAlts,1:nSpecies) + &
            PressureSRight_P12(1:nAlts,1:nSpecies))
  MeanPressureS_M12(1:nAlts,1:nSpecies) = &
        0.5*(PressureSLeft_M12(1:nAlts,1:nSpecies) + &
            PressureSRight_M12(1:nAlts,1:nSpecies))

  MeanHydroPressureS_P12(1:nAlts,1:nSpecies) = &
        0.5*(HydroPressureSLeft_P12(1:nAlts,1:nSpecies) + &
            HydroPressureSRight_P12(1:nAlts,1:nSpecies))
  MeanHydroPressureS_M12(1:nAlts,1:nSpecies) = &
        0.5*(HydroPressureSLeft_M12(1:nAlts,1:nSpecies) + &
            HydroPressureSRight_M12(1:nAlts,1:nSpecies))

!  MeanHydroPressure_P12(1:nAlts) = 0.5*(HydroPressureLeft_P12(1:nAlts) + HydroPressureRight_P12(1:nAlts))
!  MeanHydroPressure_M12(1:nAlts) = 0.5*(HydroPressureLeft_M12(1:nAlts) + HydroPressureRight_M12(1:nAlts))

  MeanRhoS_P12(1:nAlts,1:nSpecies) = 0.5*(RhoSLeft_P12(1:nAlts,1:nSpecies) + RhoSRight_P12(1:nAlts,1:nSpecies))
  MeanRhoS_M12(1:nAlts,1:nSpecies) = 0.5*(RhoSLeft_M12(1:nAlts,1:nSpecies) + RhoSRight_M12(1:nAlts,1:nSpecies))

!  MeanRho_P12(1:nAlts) = 0.5*(RhoLeft_P12(1:nAlts) + RhoRight_P12(1:nAlts))
!  MeanRho_M12(1:nAlts) = 0.5*(RhoLeft_M12(1:nAlts) + RhoRight_M12(1:nAlts))


  do iAlt = 1, nAlts 
     MeanCS_P12(iAlt) = InterfaceCS_P12(iAlt)
     MeanCS_M12(iAlt) = InterfaceCS_M12(iAlt)
  enddo 

!!! Next, define local mach numbers at the interfaces

   do iAlt = 1, nAlts 
     do iSpecies = 1, nSpecies

        MLeft_M12(iAlt,iSpecies) = &
           VelLeft_M12(iAlt,iSpecies)/MeanCS_M12(iAlt)

        MRight_M12(iAlt,iSpecies) = &
           VelRight_M12(iAlt,iSpecies)/MeanCS_M12(iAlt)

        MLeft_P12(iAlt,iSpecies) = &
           VelLeft_P12(iAlt,iSpecies)/MeanCS_P12(iAlt)

        MRight_P12(iAlt,iSpecies) = &
           VelRight_P12(iAlt,iSpecies)/MeanCS_P12(iAlt)
    
     enddo 
   enddo 

     do iSpecies = 1, nSpecies
        M2Bar_M12(1:nAlts,iSpecies) = &
           0.5*(MLeft_M12(1:nAlts,iSpecies)**2.0 + MRight_M12(1:nAlts,iSpecies)**2.0 )

        M2Bar_P12(1:nAlts,iSpecies) = &
           0.5*(MLeft_P12(1:nAlts,iSpecies)**2.0 + MRight_P12(1:nAlts,iSpecies)**2.0 )
     enddo 

     do iSpecies = 1, nSpecies
      do iAlt = 1, nAlts 

        M2Zero_M12(iAlt,iSpecies) = min(1.0, max(M2Bar_M12(iAlt,iSpecies), MInf)) 
        M2Zero_P12(iAlt,iSpecies) = min(1.0, max(M2Bar_P12(iAlt,iSpecies), MInf)) 

        MZero_M12(iAlt,iSpecies) = sqrt(M2Zero_M12(iAlt,iSpecies))
        MZero_P12(iAlt,iSpecies) = sqrt(M2Zero_P12(iAlt,iSpecies))

      enddo 
     enddo 

     do iSpecies = 1, nSpecies
      do iAlt = 1, nAlts 

        FA_M12(iAlt,iSpecies) = MZero_M12(iAlt,iSpecies)*(2.0 - MZero_M12(iAlt,iSpecies))
        FA_P12(iAlt,iSpecies) = MZero_P12(iAlt,iSpecies)*(2.0 - MZero_P12(iAlt,iSpecies))

      enddo 
     enddo 


   do iSpecies = 1, nSpecies
     do iAlt = 1, nAlts

       MF1P_Left_M12(iAlt,iSpecies) = 0.5*(MLeft_M12(iAlt,iSpecies) + abs(MLeft_M12(iAlt,iSpecies)) )
       MF1N_Left_M12(iAlt,iSpecies) = 0.5*(MLeft_M12(iAlt,iSpecies) - abs(MLeft_M12(iAlt,iSpecies)) )

       MF1P_Right_M12(iAlt,iSpecies) = 0.5*(MRight_M12(iAlt,iSpecies) + abs(MRight_M12(iAlt,iSpecies)) )
       MF1N_Right_M12(iAlt,iSpecies) = 0.5*(MRight_M12(iAlt,iSpecies) - abs(MRight_M12(iAlt,iSpecies)) )

       MF1P_Left_P12(iAlt,iSpecies) = 0.5*(MLeft_P12(iAlt,iSpecies) + abs(MLeft_P12(iAlt,iSpecies)) )
       MF1N_Left_P12(iAlt,iSpecies) = 0.5*(MLeft_P12(iAlt,iSpecies) - abs(MLeft_P12(iAlt,iSpecies)) )

       MF1P_Right_P12(iAlt,iSpecies) = 0.5*(MRight_P12(iAlt,iSpecies) + abs(MRight_P12(iAlt,iSpecies)) )
       MF1N_Right_P12(iAlt,iSpecies) = 0.5*(MRight_P12(iAlt,iSpecies) - abs(MRight_P12(iAlt,iSpecies)) )


     enddo 
  enddo 

!              MF4P_Left_M12(iAlt,iSpecies) = MF1P_Left_M12(iAlt,iSpecies)
!              MF4P_Left_M12(iAlt,iSpecies) = MF2P_Left_M12(iAlt,iSpecies)*&
!                        (1.0 - 16.0*LiouBeta*MF2N_Left_M12(iAlt,iSpecies))
!
!              MF4N_Right_M12(iAlt,iSpecies) = MF1N_Right_M12(iAlt,iSpecies)
!              MF4N_Right_M12(iAlt,iSpecies) = MF2N_Right_M12(iAlt,iSpecies)*&
!                         (1.0 + 16.0*LiouBeta*MF2P_Right_M12(iAlt,iSpecies))
!
!              MF4P_Left_P12(iAlt,iSpecies) = MF1P_Left_P12(iAlt,iSpecies)
!              MF4P_Left_P12(iAlt,iSpecies) = MF2P_Left_P12(iAlt,iSpecies)*&
!                        (1.0 - 16.0*LiouBeta*MF2N_Left_P12(iAlt,iSpecies))
!
!              MF4N_Right_P12(iAlt,iSpecies) = MF1N_Right_P12(iAlt,iSpecies)
!              MF4N_Right_P12(iAlt,iSpecies) = MF2N_Right_P12(iAlt,iSpecies)*&
!                         (1.0 + 16.0*LiouBeta*MF2P_Right_P12(iAlt,iSpecies))


   do iSpecies = 1, nSpecies
     do iAlt = 1, nAlts

       MF2P_Left_M12(iAlt,iSpecies) =  0.25*(MLeft_M12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Left_M12(iAlt,iSpecies) = -0.25*(MLeft_M12(iAlt,iSpecies) - 1.0)**2.0

       MF2P_Right_M12(iAlt,iSpecies) =  0.25*(MRight_M12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Right_M12(iAlt,iSpecies) = -0.25*(MRight_M12(iAlt,iSpecies) - 1.0)**2.0

       MF2P_Left_P12(iAlt,iSpecies) =  0.25*(MLeft_P12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Left_P12(iAlt,iSpecies) = -0.25*(MLeft_P12(iAlt,iSpecies) - 1.0)**2.0

       MF2P_Right_P12(iAlt,iSpecies) =  0.25*(MRight_P12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Right_P12(iAlt,iSpecies) = -0.25*(MRight_P12(iAlt,iSpecies) - 1.0)**2.0

     enddo 
  enddo 


!!! Begin 4th Order Mach Number Polynomials
  do iSpecies = 1, nSpecies
    do iAlt = 1, nAlts 


           if ( abs(MLeft_M12(iAlt,iSpecies)) .ge. 1.0) then 
              MF4P_Left_M12(iAlt,iSpecies) = MF1P_Left_M12(iAlt,iSpecies)
           !   MF4N_Left_M12(iAlt,iSpecies) = MF1N_Left_M12(iAlt,iSpecies)
           else
              MF4P_Left_M12(iAlt,iSpecies) = MF2P_Left_M12(iAlt,iSpecies)*&
                        (1.0 - 16.0*LiouBeta*MF2N_Left_M12(iAlt,iSpecies))
           !   MF4N_Left_M12(iAlt,iSpecies) = MF2N_Left_M12(iAlt,iSpecies)*&
           !             (1.0 + 16.0*LiouBeta*MF2P_Left_M12(iAlt,iSpecies))
           endif 


           if ( abs(MRight_M12(iAlt,iSpecies)) .ge. 1.0) then 
!              MF4P_Right_M12(iAlt,iSpecies) = MF1P_Right_M12(iAlt,iSpecies)
              MF4N_Right_M12(iAlt,iSpecies) = MF1N_Right_M12(iAlt,iSpecies)
           else
!              MF4P_Right_M12(iAlt,iSpecies) = MF2P_Right_M12(iAlt,iSpecies)*&
!                         (1.0 - 16.0*LiouBeta*MF2N_Right_M12(iAlt,iSpecies))
              MF4N_Right_M12(iAlt,iSpecies) = MF2N_Right_M12(iAlt,iSpecies)*&
                         (1.0 + 16.0*LiouBeta*MF2P_Right_M12(iAlt,iSpecies))
           endif 

           if ( abs(MLeft_P12(iAlt,iSpecies)) .ge. 1.0) then 
              MF4P_Left_P12(iAlt,iSpecies) = MF1P_Left_P12(iAlt,iSpecies)
              !MF4N_Left_P12(iAlt,iSpecies) = MF1N_Left_P12(iAlt,iSpecies)
           else
              MF4P_Left_P12(iAlt,iSpecies) = MF2P_Left_P12(iAlt,iSpecies)*&
                        (1.0 - 16.0*LiouBeta*MF2N_Left_P12(iAlt,iSpecies))
              !MF4N_Left_P12(iAlt,iSpecies) = MF2N_Left_P12(iAlt,iSpecies)*&
              !          (1.0 + 16.0*LiouBeta*MF2P_Left_P12(iAlt,iSpecies))
           endif 



           if ( abs(MRight_P12(iAlt,iSpecies)) .ge. 1.0) then 
!              MF4P_Right_P12(iAlt,iSpecies) = MF1P_Right_P12(iAlt,iSpecies)
              MF4N_Right_P12(iAlt,iSpecies) = MF1N_Right_P12(iAlt,iSpecies)
           else
!              MF4P_Right_P12(iAlt,iSpecies) = MF2P_Right_P12(iAlt,iSpecies)*&
!                        (1.0 - 16.0*LiouBeta*MF2N_Right_P12(iAlt,iSpecies))
              MF4N_Right_P12(iAlt,iSpecies) = MF2N_Right_P12(iAlt,iSpecies)*&
                         (1.0 + 16.0*LiouBeta*MF2P_Right_P12(iAlt,iSpecies))
           endif 


    enddo 
  enddo 

!!! Begin 2nd Order Mach Number Polynomials
  do iSpecies = 1, nSpecies
    do iAlt = 1, nAlts 

       ModifiedZeta(iAlt,iSpecies) = 1.0

!!!! Hydrostatic Species Use This one
       MPress_M12(iAlt,iSpecies) = &
         LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
         ((PressureSRight_M12(iAlt, iSpecies) - &
         HydroPressureSRight_M12(iAlt,iSpecies) ) - &
         (PressureSLeft_M12(iAlt, iSpecies) - &
          HydroPressureSLeft_M12(iAlt,iSpecies) ) )/ &
         ( MeanRhoS_M12(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
         (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + &
          ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 

       MPress_P12(iAlt,iSpecies) = &
          LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
          (  (PressureSRight_P12(iAlt, iSpecies) - &
          HydroPressureSRight_P12(iAlt,iSpecies) ) - &
          (PressureSLeft_P12(iAlt, iSpecies) - &
          HydroPressureSLeft_P12(iAlt,iSpecies) ) )/ &
          ( MeanRhoS_P12(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
          (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + &
           ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 

!!!!! Non-Hydrostatic Species Should use this version

       if (SubtractHydrostatic(iAlt,iSpecies) .eq. .false.) then

       MPress_P12(iAlt,iSpecies) = &
          LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
          (PressureSRight_P12(iAlt, iSpecies) - PressureSLeft_P12(iAlt,iSpecies) )/&
          ( MeanRhoS_P12(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
          (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + &
          ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 

       MPress_M12(iAlt,iSpecies) = &
         LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
         (PressureSRight_M12(iAlt, iSpecies) - PressureSLeft_M12(iAlt,iSpecies) )/&
         ( MeanRhoS_M12(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
         (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + &
          ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 


       endif 
    enddo ! iSpecies
  enddo ! iAlt


   do iAlt = 1, nAlts 
      do iSpecies = 1, nSpecies

          InterfaceMach_M12(iAlt,iSpecies) =  &
                 MF4P_Left_M12(iAlt,iSpecies) + MF4N_Right_M12(iAlt,iSpecies) &
                    - MPress_M12(iAlt,iSpecies)

          LiouNumericalVelocity_M12(iAlt,iSpecies) = &
                   MeanCS_M12(iAlt)*InterfaceMach_M12(iAlt,iSpecies) 

          InterfaceMach_P12(iAlt,iSpecies) =  &
                 MF4P_Left_P12(iAlt,iSpecies) + MF4N_Right_P12(iAlt,iSpecies) &
                    - MPress_P12(iAlt,iSpecies)
 
          LiouNumericalVelocity_P12(iAlt,iSpecies) = &
                   MeanCS_P12(iAlt)*InterfaceMach_P12(iAlt,iSpecies) 
      enddo ! iSpecies 
   enddo  ! iAlt

      NumericalVelocity_M12(1:nAlts,1:nSpecies) = &
  LiouNumericalVelocity_M12(1:nAlts,1:nSpecies)

      NumericalVelocity_P12(1:nAlts,1:nSpecies) = &
  LiouNumericalVelocity_P12(1:nAlts,1:nSpecies)


  do iSpecies = 1, nSpecies
       do iAlt = 1, nAlts

             NumericalPressure_P12(iAlt,iSpecies) = &
                  (MeanPressureS_P12(iAlt,iSpecies) - &
              MeanHydroPressureS_P12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
               ( (RhoSRight_P12(iAlt,iSpecies) )*VelRight_P12(iAlt,iSpecies) - &
                  (RhoSLeft_P12(iAlt,iSpecies) )* VelLeft_P12(iAlt,iSpecies) )

             NumericalPressure_M12(iAlt,iSpecies) = &
               (MeanPressureS_M12(iAlt,iSpecies) - &
           MeanHydroPressureS_M12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
               ( (RhoSRight_M12(iAlt,iSpecies) )*VelRight_M12(iAlt,iSpecies) - &
                  (RhoSLeft_M12(iAlt,iSpecies) )* VelLeft_M12(iAlt,iSpecies) )

      
       if (SubtractHydrostatic(iAlt,iSpecies) .eq. .false.) then

             NumericalPressure_P12(iAlt,iSpecies) = &
               (MeanPressureS_P12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
               ( (RhoSRight_P12(iAlt,iSpecies) )*VelRight_P12(iAlt,iSpecies) - &
                  (RhoSLeft_P12(iAlt,iSpecies) )* VelLeft_P12(iAlt,iSpecies) )

             NumericalPressure_M12(iAlt,iSpecies) = &
               (MeanPressureS_M12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
               ( (RhoSRight_M12(iAlt,iSpecies) )*VelRight_M12(iAlt,iSpecies) - &
                  (RhoSLeft_M12(iAlt,iSpecies) )* VelLeft_M12(iAlt,iSpecies) )

       endif 
           
       enddo !!iAlt = 1, nAlts
  enddo !!! nSpecies

!!! ==============================================================================
!!! ==============================================================================


            HorizBulkNumericalVelocity_P12(1:nAlts) = &
              0.5*(VelGDLeft_P12(1:nAlts,iUp_) + VelGDRight_P12(1:nAlts,iUp_))

            HorizBulkNumericalVelocity_M12(1:nAlts) = &
              0.5*(VelGDLeft_M12(1:nAlts,iUp_) + VelGDRight_M12(1:nAlts,iUp_))

            BulkIVel_P12(1:nAlts) = &
              0.5*(IVelLeft_P12(1:nAlts,iUp_) + IVelRight_P12(1:nAlts,iUp_))

            BulkIVel_M12(1:nAlts) = &
              0.5*(IVelLeft_M12(1:nAlts,iUp_) + IVelRight_M12(1:nAlts,iUp_))

    BulkNumericalVelocity_P12(1:nAlts) = 0.0
    BulkNumericalVelocity_M12(1:nAlts) = 0.0

    do iSpecies = 1, nSpecies
        BulkNumericalVelocity_P12(1:nAlts) = &
        BulkNumericalVelocity_P12(1:nAlts) + &
           ( RhoSLeft_P12(1:nAlts,iSpecies) + RhoSRight_P12(1:nAlts,iSpecies) )*&
             NumericalVelocity_P12(1:nAlts,iSpecies)/&
             (RhoLeft_P12(1:nAlts) + RhoRight_P12(1:nAlts) )

        BulkNumericalVelocity_M12(1:nAlts) = &
        BulkNumericalVelocity_M12(1:nAlts) + &
           ( RhoSLeft_M12(1:nAlts,iSpecies) + RhoSRight_M12(1:nAlts,iSpecies) )*&
             NumericalVelocity_M12(1:nAlts,iSpecies)/&
             (RhoLeft_M12(1:nAlts) + RhoRight_M12(1:nAlts) )
    enddo 




    do iSpecies = 1, nSpecies
       do iAlt = 1, nAlts 

       if (NumericalVelocity_P12(iAlt,iSpecies) .ge. 0.0) then 

          RhoSFlux_P12(iAlt,iSpecies) = &
              (RhoSLeft_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies)) 

          MomentumSFlux_P12(iAlt,iSpecies) = &
              (RhoSLeft_P12(iAlt,iSpecies)*VelLeft_P12(iAlt,iSpecies)*&
              NumericalVelocity_P12(iAlt,iSpecies)) 


       else
          RhoSFlux_P12(iAlt,iSpecies) = &
              (RhoSRight_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies)) 

          MomentumSFlux_P12(iAlt,iSpecies) = &
              (RhoSRight_P12(iAlt,iSpecies)*VelRight_P12(iAlt,iSpecies)*&
              NumericalVelocity_P12(iAlt,iSpecies)) 
       endif


       if (NumericalVelocity_M12(iAlt,iSpecies) .ge. 0.0) then 

          RhoSFlux_M12(iAlt,iSpecies) = &
              (RhoSLeft_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies)) 

          MomentumSFlux_M12(iAlt,iSpecies) = &
              (RhoSLeft_M12(iAlt,iSpecies)*VelLeft_M12(iAlt,iSpecies)*&
              NumericalVelocity_M12(iAlt,iSpecies)) 

       else

          RhoSFlux_M12(iAlt,iSpecies) = &
              (RhoSRight_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies)) 

          MomentumSFlux_M12(iAlt,iSpecies) = &
              (RhoSRight_M12(iAlt,iSpecies)*VelRight_M12(iAlt,iSpecies)*&
              NumericalVelocity_M12(iAlt,iSpecies)) 

       endif

       enddo 
    enddo 

            BulkIVel_P12(1:nAlts) = &
              0.5*(IVelLeft_P12(1:nAlts,iUp_) + IVelRight_P12(1:nAlts,iUp_))

            BulkIVel_M12(1:nAlts) = &
              0.5*(IVelLeft_M12(1:nAlts,iUp_) + IVelRight_M12(1:nAlts,iUp_))

       do iAlt = 1, nAlts 
          if (BulkIVel_P12(iAlt) .ge. 0.0) then 
             RhoIFlux_P12(iAlt,1:nIonsAdvect) = &
                RhoILeft_P12(iAlt,1:nIonsAdvect) &
                 *BulkIVel_P12(iAlt) 
          else
             RhoIFlux_P12(iAlt,1:nIonsAdvect) = &
                RhoIRight_P12(iAlt,1:nIonsAdvect) &
                 *BulkIVel_P12(iAlt) 
          endif

          if (BulkIVel_M12(iAlt) .ge. 0.0) then 
             RhoIFlux_M12(iAlt,1:nIonsAdvect) = &
                RhoILeft_M12(iAlt,1:nIonsAdvect) &
                 *BulkIVel_M12(iAlt) 
          else
             RhoIFlux_M12(iAlt,1:nIonsAdvect) = &
                RhoIRight_M12(iAlt,1:nIonsAdvect) &
                 *BulkIVel_M12(iAlt) 
          endif
       enddo 


       do iAlt = 1, nAlts 
          if (BulkNumericalVelocity_P12(iAlt) .ge. 0.0) then 
!             EnergyFlux_P12(iAlt) = &
!                ELeft_P12(iAlt)*BulkNumericalVelocity_P12(iAlt) 

             EnergyFlux_P12(iAlt) = &
               ( ELeft_P12(iAlt) + PLeft_P12(iAlt) ) &
                 *BulkNumericalVelocity_P12(iAlt) 

             Momentum_P12(iAlt,1:3) = &
                RhoLeft_P12(iAlt)*VelGDLeft_P12(iAlt,1:3)*&
                BulkNumericalVelocity_P12(iAlt) 
          else
!              EnergyFlux_P12(iAlt) = &
!                 ERight_P12(iAlt)*BulkNumericalVelocity_P12(iAlt) 

             EnergyFlux_P12(iAlt) = &
               ( ERight_P12(iAlt) + PRight_P12(iAlt) ) &
                 *BulkNumericalVelocity_P12(iAlt) 

             Momentum_P12(iAlt,1:3) = &
                RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,1:3)*&
                BulkNumericalVelocity_P12(iAlt) 
 
          endif

          if (BulkNumericalVelocity_M12(iAlt) .ge. 0.0) then 
!             EnergyFlux_M12(iAlt) = &
!                ELeft_M12(iAlt)*BulkNumericalVelocity_M12(iAlt) 

             EnergyFlux_M12(iAlt) = &
               ( ELeft_M12(iAlt) + PLeft_M12(iAlt) ) &
                 *BulkNumericalVelocity_M12(iAlt) 

             Momentum_M12(iAlt,1:3) = &
                RhoLeft_M12(iAlt)*VelGDLeft_M12(iAlt,1:3)*&
                BulkNumericalVelocity_M12(iAlt) 
          else
!             EnergyFlux_M12(iAlt) = &
!                ERight_M12(iAlt)*BulkNumericalVelocity_M12(iAlt) 

             EnergyFlux_M12(iAlt) = &
               ( ERight_M12(iAlt) + PRight_M12(iAlt) ) &
                 *BulkNumericalVelocity_M12(iAlt) 

             Momentum_M12(iAlt,1:3) = &
                RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,1:3)*&
                BulkNumericalVelocity_M12(iAlt) 

          endif
       enddo !! End iAlt Loop 

!!!! Using Rusanov Fluxes
       do iAlt = 1, nAlts 
          do iDim = 1, 3

            Momentum_P12(iAlt,iDim) = & 
                 0.5*(  RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,iDim) + &
                         RhoLeft_P12(iAlt)* VelGDLeft_P12(iAlt,iDim))*&
                 HorizBulkNumericalVelocity_P12(iAlt) - &
            0.5*Kp(1)*MeanCS_P12(iAlt)*(  RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,iDim) - &
                                          RhoLeft_P12(iAlt)* VelGDLeft_P12(iAlt,iDim))

            Momentum_M12(iAlt,iDim) = & 
                 0.5*(  RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,iDim) + &
                         RhoLeft_M12(iAlt)* VelGDLeft_M12(iAlt,iDim))*&
                 HorizBulkNumericalVelocity_M12(iAlt) - & 
            0.5*Kp(1)*MeanCS_M12(iAlt)*(  RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,iDim) - &
                                           RhoLeft_M12(iAlt)* VelGDLeft_M12(iAlt,iDim))

          enddo  ! End iDim
       enddo   ! End iAlt

     do iAlt = 1, nAlts
           LeftRadius(iAlt) = 0.5*(RadDist(iAlt) + RadDist(iAlt-1))
           RightRadius(iAlt) = 0.5*(RadDist(iAlt) + RadDist(iAlt+1))
     enddo 

     do iAlt = 1, nAlts
           AreaFunction_P12(iAlt) = RightRadius(iAlt)**2.0
           AreaFunction_M12(iAlt) = LeftRadius(iAlt)**2.0
           LocalCellVolume(iAlt) = (1.0/3.0)*(RightRadius(iAlt)**3.0 - LeftRadius(iAlt)**3.0)
     enddo 

    do iSpecies = 1, nSpecies

       RhoSFlux(1:nAlts,iSpecies) = &
            ( (AreaFunction_P12(1:nAlts))*RhoSFlux_P12(1:nAlts,iSpecies) - &
              (AreaFunction_M12(1:nAlts))*RhoSFlux_M12(1:nAlts,iSpecies) )/&
              LocalCellVolume(1:nAlts)

      do iAlt = 1, nAlts

        TotalRhoFluxes_1d(iAlt,iSpecies) = &
         0.5*( (RadDist(iAlt)**2.0)/(RBody)**2.0)*&
         (RhoSFlux_P12(iAlt,iSpecies) + RhoSFlux_M12(iAlt,iSpecies))/&
         Mass(iSpecies)
      enddo 
!
       MomentumSFlux(1:nAlts,iSpecies) = &
            ( (AreaFunction_P12(1:nAlts))*MomentumSFlux_P12(1:nAlts,iSpecies) - &
              (AreaFunction_M12(1:nAlts))*MomentumSFlux_M12(1:nAlts,iSpecies) )/&
              LocalCellVolume(1:nAlts)

       MomentumSFlux(1:nAlts,iSpecies) = &
       MomentumSFlux(1:nAlts,iSpecies) + &
           (NumericalPressure_P12(1:nAlts,iSpecies) - &
            NumericalPressure_M12(1:nAlts,iSpecies))/dAlt_C(1:nAlts)
    enddo 

    do iSpecies = 1, nIonsAdvect
       RhoIFlux(1:nAlts,iSpecies) = &
            ( (AreaFunction_P12(1:nAlts))*RhoIFlux_P12(1:nAlts,iSpecies) - &
              (AreaFunction_M12(1:nAlts))*RhoIFlux_M12(1:nAlts,iSpecies) )/&
              LocalCellVolume(1:nAlts)
    enddo 


       EnergyFluxes(1:nAlts) = &
            ( (AreaFunction_P12(1:nAlts))*EnergyFlux_P12(1:nAlts) - &
              (AreaFunction_M12(1:nAlts))*EnergyFlux_M12(1:nAlts))/&
              LocalCellVolume(1:nAlts)

     do iDim = 1, 3
       MomentumFluxes(1:nAlts,iDim) = &
            ( AreaFunction_P12(1:nAlts)*Momentum_P12(1:nAlts,iDim) - &
              AreaFunction_M12(1:nAlts)*Momentum_M12(1:nAlts,iDim))/&
              LocalCellVolume(1:nAlts)
     enddo 

!   call end_timing("AUSM_Fluxes")

end subroutine calc_all_fluxes_hydro




 subroutine calc_kt_facevalues(Var, VarLeft_M12, VarRight_M12, &
                                    VarLeft_P12, VarRight_P12)
 
 
   use ModVertical, only: dAlt_F, InvDAlt_F
   use ModSizeGITM, only: nAlts
   use ModLimiterGitm
 
   implicit none
   
   real, intent(in) :: Var(-1:nAlts+2)
   real, intent(out):: VarLeft_P12(1:nAlts), VarRight_P12(1:nAlts)
   real, intent(out):: VarLeft_M12(1:nAlts), VarRight_M12(1:nAlts)
 
   real :: dVarUp, dVarDown, dVarLimited(0:nAlts+1)
 
   integer :: i


!!!!!! TREAT THE LOWER BOUNDARY SEPARATELY

        do i=0,nAlts+1
             dVarUp            = (Var(i+1) - Var(i  ))   * InvDAlt_F(i+1)
             dVarDown          = (Var(i  ) - Var(i-1)) * InvDAlt_F(i)
             dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)
        end do

        do i=1,nAlts
            VarLeft_M12(i) = Var(i-1) + 0.5*dVarLimited(i-1) * dAlt_F(i-1)
           VarRight_M12(i) = Var(i  ) - 0.5*dVarLimited(i  ) * dAlt_F(i  )
      
            VarLeft_P12(i) = Var(i  ) + 0.5*dVarLimited(i  ) * dAlt_F(i  )
           VarRight_P12(i) = Var(i+1) - 0.5*dVarLimited(i+1) * dAlt_F(i+1)
        end do
 
 
!        do i=1,nAlts
!            VarLeft_M12(i) = Var(i-1) + 0.5*dVarLimited(i-1) * dAlt_F(i  )
!           VarRight_M12(i) = Var(i  ) - 0.5*dVarLimited(i  ) * dAlt_F(i  )
!      
!            VarLeft_P12(i) = Var(i  ) + 0.5*dVarLimited(i  ) * dAlt_F(i+1)
!           VarRight_P12(i) = Var(i+1) - 0.5*dVarLimited(i+1) * dAlt_F(i+1)
!        end do

 end subroutine calc_kt_facevalues



