
!\
! ------------------------------------------------------------
! advance
! ------------------------------------------------------------
!/

subroutine advance_vertical_1d

  use ModVertical
  use ModGITM, ONLY : Dt, iCommGITM, iProc, iEast_, iNorth_, iUp_
  use ModInputs, only: UseBarriers, iDebugLevel
  use ModPlanet, only: iN2_
  implicit none
  !-----------------------------------------------------------

  integer :: iError, iAlt


!!!!! Variables for the Runga-Kutta (3) Time-stepping
  real :: OrigLogNS(-1:nAlts+2,1:nSpecies)
  real :: OrigLogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: OrigLogRho(-1:nAlts+2)
  real :: OrigVel_GD(-1:nAlts+2,1:3)
  real :: OrigTemp(-1:nAlts+2)
  real :: OrigVS(-1:nAlts+2,1:nSpecies)
  real :: OrigTempS(-1:nAlts+2,1:nSpecies)

  real :: Stage1LogNS(-1:nAlts+2,1:nSpecies)
  real :: Stage1LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: Stage1LogRho(-1:nAlts+2)
  real :: Stage1Vel_GD(-1:nAlts+2,1:3)
  real :: Stage1Temp(-1:nAlts+2)
  real :: Stage1VS(-1:nAlts+2,1:nSpecies)
  real :: Stage1TempS(-1:nAlts+2,1:nSpecies)
  
  real :: Stage2LogNS(-1:nAlts+2,1:nSpecies)
  real :: Stage2LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: Stage2LogRho(-1:nAlts+2)
  real :: Stage2Vel_GD(-1:nAlts+2,1:3)
  real :: Stage2Temp(-1:nAlts+2)
  real :: Stage2VS(-1:nAlts+2,1:nSpecies)
  real :: Stage2TempS(-1:nAlts+2,1:nSpecies)

  real :: Stage3LogNS(-1:nAlts+2,1:nSpecies)
  real :: Stage3LogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: Stage3LogRho(-1:nAlts+2)
  real :: Stage3Vel_GD(-1:nAlts+2,1:3)
  real :: Stage3Temp(-1:nAlts+2)
  real :: Stage3VS(-1:nAlts+2,1:nSpecies)
  real :: Stage3TempS(-1:nAlts+2,1:nSpecies)

  real :: FinalLogNS(-1:nAlts+2,1:nSpecies)
  real :: FinalLogINS(-1:nAlts+2,1:nIonsAdvect)
  real :: FinalLogRho(-1:nAlts+2)
  real :: FinalVel_GD(-1:nAlts+2,1:3)
  real :: FinalTemp(-1:nAlts+2)
  real :: FinalVS(-1:nAlts+2,1:nSpecies)
  real :: FinalTempS(-1:nAlts+2,1:nSpecies)

  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 6) write(*,*) "=======> vertical bcs 1", iproc

  ! Fill in ghost cells
  call set_vertical_bcs(LogRho,LogNS,Vel_GD,Temp,LogINS,IVel,VertVel, TempS)

  ! Copy input state into  state

!  write(*,*) 'Set the Original State'

!!! Set the Original State
  OrigLogNS(-1:nAlts+2,1:nSpecies)  = LogNS(-1:nAlts+2,1:nSpecies)
  OrigLogINS(-1:nAlts+2,1:nIonsAdvect) = LogINS(-1:nAlts+2,1:nIonsAdvect)
  OrigLogRho(-1:nAlts+2) = LogRho(-1:nAlts+2)
  OrigVel_GD(-1:nAlts+2,1:3) = Vel_GD(-1:nAlts+2,1:3)
  OrigTemp(-1:nAlts+2)   = Temp(-1:nAlts+2)
  OrigVS(-1:nAlts+2,1:nSpecies) = VertVel(-1:nAlts+2,1:nSpecies)
  OrigTempS(-1:nAlts+2,1:nSpecies) = TempS(-1:nAlts+2,1:nSpecies)

  NewLogNS = LogNS
  NewLogINS = LogINS
  NewLogRho = LogRho
  NewVel_GD = Vel_GD
  NewTemp = Temp
  NewVertVel = VertVel
  NewTempS = TempS


!!! =================

!  write(*,*) 'BEGIN Stage 1'
!!!!! Call Update Cycle ========================================
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> stage 1", iproc

  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel, TempS, NewTempS)

!  write(*,*) 'Testing NewLogNS After vertical_Solver =', NewLogNS(-1,1)

  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> vertical bcs 3", iproc


!!!!! END Update Cycle ========================================
!  write(*,*) 'Finish Stage 1'

!!! Set the Updated State:  Stage 1
!!! Let's update the Physical Cells accodring to RK-3 (Ullrich et al. [2011])
!!! Set the Bottom Ghost Cells according to the Original State and then
!!! Update BCS for Stage 1 with a call to set_vertical_bcs.f90

!!! Set the Updated State:  Stage 1
  Stage1LogNS(1:nAlts,1:nSpecies)      = OrigLogNS(1:nAlts,1:nSpecies) +  &
                         0.5*(NewLogNS(1:nAlts,1:nSpecies) - LogNS(1:nAlts,1:nSpecies))
  Stage1LogINS(1:nAlts,1:nIonsAdvect)  = OrigLogINS(1:nAlts,1:nIonsAdvect) + &
                         0.5*(NewLogINS(1:nAlts,1:nIonsAdvect) - LogINS(1:nAlts,1:nIonsAdvect))
  Stage1LogRho(1:nAlts)                = OrigLogRho(1:nAlts) + 0.5*(NewLogRho(1:nAlts) - LogRho(1:nAlts))
  Stage1Vel_GD(1:nAlts,1:3)            = OrigVel_GD(1:nAlts,1:3) + 0.5*(NewVel_GD(1:nAlts,1:3) - Vel_GD(1:nAlts,1:3))
  Stage1Temp(1:nAlts)                  = OrigTemp(1:nAlts) + 0.5*(NewTemp(1:nAlts) - Temp(1:nAlts))
  Stage1VS(1:nAlts,1:nSpecies)         = OrigVS(1:nAlts,1:nSpecies) + &
                         0.5*(NewVertVel(1:nAlts,1:nSpecies) - VertVel(1:nAlts,1:nSpecies))

  Stage1TempS(1:nAlts,1:nSpecies)         = OrigTempS(1:nAlts,1:nSpecies) + &
                         0.5*(NewTempS(1:nAlts,1:nSpecies) - TempS(1:nAlts,1:nSpecies))

!!! Fill Bottom Cells with the Original State
  Stage1LogNS(-1:0,1:nSpecies)     = OrigLogNS(-1:0,1:nSpecies) 
  Stage1LogINS(-1:0,1:nIonsAdvect) = OrigLogINS(-1:0,1:nIonsAdvect) 
  Stage1LogRho(-1:0)               = OrigLogRho(-1:0) 
  Stage1Vel_GD(-1:0,1:3)           = OrigVel_GD(-1:0,1:3) 
  Stage1Temp(-1:0)                 = OrigTemp(-1:0) 
  Stage1VS(-1:0,1:nSpecies)        = OrigVS(-1:0,1:nSpecies) 
  Stage1TempS(-1:0,1:nSpecies)     = OrigTempS(-1:0,1:nSpecies) 


!!! UpdateStage 1 Upper Boundary
  call set_vertical_bcs(Stage1LogRho, Stage1LogNS, Stage1Vel_GD, &
                   Stage1Temp, Stage1LogINS, IVel, Stage1VS, Stage1TempS)

  LogNS  = Stage1LogNS
  LogINS = Stage1LogINS
  LogRho = Stage1LogRho
  Vel_GD = Stage1Vel_GD
  Temp = Stage1Temp
  VertVel = Stage1VS
  TempS = Stage1TempS

  NewLogNS = LogNS
  NewLogINS = LogINS
  NewLogRho = LogRho
  NewVel_GD = Vel_GD
  NewTemp = Temp
  NewVertVel = VertVel
  NewTempS = TempS

!  write(*,*) 'Testing LogNS Before Stage2 =', LogNS(-1,1)

!  write(*,*) 'BEGIN Stage 2'
!!!!! Call Update Cycle ========================================
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> stage 1", iproc

  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel, TempS, NewTempS)

  
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> vertical bcs 3", iproc

!!!!! END Update Cycle ========================================
!  write(*,*) 'END Stage 2'


!!! Set the Updated State:  Stage 2
  Stage2LogNS(1:nAlts,1:nSpecies)      = OrigLogNS(1:nAlts,1:nSpecies) +  &
                         0.5*(NewLogNS(1:nAlts,1:nSpecies) - LogNS(1:nAlts,1:nSpecies))
  Stage2LogINS(1:nAlts,1:nIonsAdvect)  = OrigLogINS(1:nAlts,1:nIonsAdvect) + &
                         0.5*(NewLogINS(1:nAlts,1:nIonsAdvect) - LogINS(1:nAlts,1:nIonsAdvect))
  Stage2LogRho(1:nAlts)                = OrigLogRho(1:nAlts) + 0.5*(NewLogRho(1:nAlts) - LogRho(1:nAlts))
  Stage2Vel_GD(1:nAlts,1:3)            = OrigVel_GD(1:nAlts,1:3) + 0.5*(NewVel_GD(1:nAlts,1:3) - Vel_GD(1:nAlts,1:3))
  Stage2Temp(1:nAlts)                  = OrigTemp(1:nAlts) + 0.5*(NewTemp(1:nAlts) - Temp(1:nAlts))
  Stage2VS(1:nAlts,1:nSpecies)         = OrigVS(1:nAlts,1:nSpecies) +&
                          0.5*(NewVertVel(1:nAlts,1:nSpecies) - VertVel(1:nAlts,1:nSpecies))

  Stage2TempS(1:nAlts,1:nSpecies)      = OrigTempS(1:nAlts,1:nSpecies) +&
                          0.5*(NewTempS(1:nAlts,1:nSpecies) - TempS(1:nAlts,1:nSpecies))

!!! Fill Bottom Cells with the Original State
  Stage2LogNS(-1:0,1:nSpecies)     = OrigLogNS(-1:0,1:nSpecies) 
  Stage2LogINS(-1:0,1:nIonsAdvect) = OrigLogINS(-1:0,1:nIonsAdvect) 
  Stage2LogRho(-1:0)               = OrigLogRho(-1:0) 
  Stage2Vel_GD(-1:0,1:3)           = OrigVel_GD(-1:0,1:3) 
  Stage2Temp(-1:0)                 = OrigTemp(-1:0) 
  Stage2VS(-1:0,1:nSpecies)        = OrigVS(-1:0,1:nSpecies) 
  Stage2TempS(-1:0,1:nSpecies)     = OrigTempS(-1:0,1:nSpecies) 


  call set_vertical_bcs(Stage2LogRho, Stage2LogNS, Stage2Vel_GD, &
                        Stage2Temp, Stage2LogINS, IVel, Stage2VS, Stage2TempS)

  LogNS  = Stage2LogNS
  LogINS = Stage2LogINS
  LogRho = Stage2LogRho
  Vel_GD = Stage2Vel_GD
  Temp = Stage2Temp
  VertVel = Stage2VS
  TempS = Stage2TempS

  NewLogNS = LogNS
  NewLogINS = LogINS
  NewLogRho = LogRho
  NewVel_GD = Vel_GD
  NewTemp = Temp
  NewVertVel = VertVel
  NewTempS = TempS


!!!!! Call Update Cycle ========================================
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> stage 1", iproc

  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel, TempS, NewTempS)
  
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> vertical bcs 3", iproc


!!! Set the Updated State:  Stage 3
  Stage3LogNS(1:nAlts,1:nSpecies)      = OrigLogNS(1:nAlts,1:nSpecies) +  &
                         (NewLogNS(1:nAlts,1:nSpecies) - LogNS(1:nAlts,1:nSpecies))
  Stage3LogINS(1:nAlts,1:nIonsAdvect)  = OrigLogINS(1:nAlts,1:nIonsAdvect) + &
                         (NewLogINS(1:nAlts,1:nIonsAdvect) - LogINS(1:nAlts,1:nIonsAdvect))
  Stage3LogRho(1:nAlts)                = OrigLogRho(1:nAlts) + (NewLogRho(1:nAlts) - LogRho(1:nAlts))
  Stage3Vel_GD(1:nAlts,1:3)            = OrigVel_GD(1:nAlts,1:3) + (NewVel_GD(1:nAlts,1:3) - Vel_GD(1:nAlts,1:3))
  Stage3Temp(1:nAlts)                  = OrigTemp(1:nAlts) + (NewTemp(1:nAlts) - Temp(1:nAlts))
  Stage3VS(1:nAlts,1:nSpecies)         = OrigVS(1:nAlts,1:nSpecies) +&
                          (NewVertVel(1:nAlts,1:nSpecies) - VertVel(1:nAlts,1:nSpecies))
  Stage3TempS(1:nAlts,1:nSpecies)      = OrigTempS(1:nAlts,1:nSpecies) +&
                          (NewTempS(1:nAlts,1:nSpecies) - TempS(1:nAlts,1:nSpecies))

!!! Fill Bottom Cells with the Original State
  Stage3LogNS(-1:0,1:nSpecies)     = OrigLogNS(-1:0,1:nSpecies) 
  Stage3LogINS(-1:0,1:nIonsAdvect) = OrigLogINS(-1:0,1:nIonsAdvect) 
  Stage3LogRho(-1:0)               = OrigLogRho(-1:0) 
  Stage3Vel_GD(-1:0,1:3)           = OrigVel_GD(-1:0,1:3) 
  Stage3Temp(-1:0)                 = OrigTemp(-1:0) 
  Stage3VS(-1:0,1:nSpecies)        = OrigVS(-1:0,1:nSpecies) 
  Stage3TempS(-1:0,1:nSpecies)     = OrigTempS(-1:0,1:nSpecies) 

!!!! ====== Stage3
  call set_vertical_bcs(Stage3LogRho, Stage3LogNS, Stage3Vel_GD, &
                        Stage3Temp, Stage3LogINS, IVel, Stage3VS, Stage3TempS)

  LogNS   = Stage3LogNS
  LogINS  = Stage3LogINS
  LogRho  = Stage3LogRho
  Vel_GD  = Stage3Vel_GD
  Temp    = Stage3Temp
  VertVel = Stage3VS
  TempS   = Stage3TempS

  NewLogNS = LogNS
  NewLogINS = LogINS
  NewLogRho = LogRho
  NewVel_GD = Vel_GD
  NewTemp = Temp
  NewVertVel = VertVel
  NewTempS = TempS

!!!!! Call Update Cycle ========================================
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> stage 1", iproc

  call advance_vertical_1stage(&
       LogRho, LogNS, Vel_GD, Temp, NewLogRho, NewLogNS, NewVel_GD, NewTemp, &
       LogINS, NewLogINS, IVel, VertVel, NewVertVel, TempS, NewTempS)
  
  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) write(*,*) "========> vertical bcs 3", iproc

!!!!! END Update Cycle ========================================

!!! Set the Updated State:  Stage 2
  FinalLogNS  = (1.0/3.0)*(-1.0*OrigLogNS  + 1.0*Stage1LogNS  + 2.0*Stage2LogNS  + 1.0*Stage3LogNS + 0.5*(NewLogNS - LogNS) )
  FinalLogINS = (1.0/3.0)*(-1.0*OrigLogINS + 1.0*Stage1LogINS + 2.0*Stage2LogINS + 1.0*Stage3LogINS + 0.5*(NewLogINS - LogINS) )
  FinalLogRho = (1.0/3.0)*(-1.0*OrigLogRho + 1.0*Stage1LogRho + 2.0*Stage2LogRho + 1.0*Stage3LogRho + 0.5*(NewLogRho - LogRho))
  FinalVel_GD = (1.0/3.0)*(-1.0*OrigVel_GD + 1.0*Stage1Vel_GD + 2.0*Stage2Vel_GD + 1.0*Stage3Vel_GD + 0.5*(NewVel_GD - Vel_GD))
  FinalTemp   = (1.0/3.0)*(-1.0*OrigTemp   + 1.0*Stage1Temp   + 2.0*Stage2Temp   + 1.0*Stage3Temp + 0.5*(NewTemp - Temp))
  FinalVS     = (1.0/3.0)*(-1.0*OrigVS     + 1.0*Stage1VS     + 2.0*Stage2VS     + 1.0*Stage3VS + 0.5*(NewVertVel - VertVel))
  FinalTempS  = (1.0/3.0)*(-1.0*OrigTempS  + 1.0*Stage1TempS  + 2.0*Stage2TempS  + 1.0*Stage3TempS + 0.5*(NewTempS - TempS))


!!! Fill Bottom Cells with the Original State
  FinalLogNS(-1:0,1:nSpecies)     = OrigLogNS(-1:0,1:nSpecies) 
  FinalLogINS(-1:0,1:nIonsAdvect) = OrigLogINS(-1:0,1:nIonsAdvect) 
  FinalLogRho(-1:0)               = OrigLogRho(-1:0) 
  FinalVel_GD(-1:0,1:3)           = OrigVel_GD(-1:0,1:3) 
  FinalTemp(-1:0)                 = OrigTemp(-1:0) 
  FinalVS(-1:0,1:nSpecies)        = OrigVS(-1:0,1:nSpecies) 
  FinalTempS(-1:0,1:nSpecies)     = OrigTempS(-1:0,1:nSpecies) 

!  write(*,*) 'Final OUTPUT :======', FinalVS(2,iN2_), FinalVS(1,iN2_), FinalVS(0,iN2_), FinalVS(-1,iN2_)

  call set_vertical_bcs(FinalLogRho, FinalLogNS, FinalVel_GD,&
                        FinalTemp, FinalLogINS, IVel, FinalVS, FinalTempS)

!!! Set the Updated State:  Stage 2

   LogNS = FinalLogNS
  LogINS = FinalLogINS
  LogRho = FinalLogRho
  Vel_GD = FinalVel_GD
    Temp = FinalTemp
 VertVel = FinalVS
   TempS = FinalTempS

  if (UseBarriers) call MPI_BARRIER(iCommGITM,iError)
  if (iDebugLevel > 7) &
       write(*,*) "========> Done with advance_vertical_1d", iproc


end subroutine advance_vertical_1d

!=============================================================================
subroutine advance_vertical_1stage( &
     LogRho, LogNS, Vel_GD, Temp, NewLogRho, NewLogNS, NewVel_GD, NewTemp, &
     LogINS, NewLogINS, IVel, VertVel, NewVertVel, TempS, NewTempS)

  ! With fluxes and sources based on LogRho..Temp, update NewLogRho..NewTemp

  use ModGITM, only: &
       Dt, iEast_, iNorth_, iUp_
  use ModPlanet
  use ModSizeGitm
  use ModVertical, only : &
       Heating, EddyCoef_1D, ViscCoef_1d,Centrifugal, Coriolis, &
       MeanMajorMass_1d, Gamma_1d, InvRadialDistance_C, &
       Gravity_G, Altitude_G,Cv_1D, dAlt_F, &
       ChemSources_1d, &
       GammaS_1d, &
       VS1D_HydrostaticPressureS, &
       VS1D_HydrostaticRhoS, &
       VS1D_DeviationPressureS, &
       VS1D_DeviationRhoS, &
       VS1D_GradLogCon, &
       VS1D_EddyVelocity, &
       VS1D_NewTotalEnergy

  use ModTime
  use ModInputs
  use ModConstants

  implicit none

  real, intent(in) :: LogRho(-1:nAlts+2)
  real, intent(in) :: LogNS(-1:nAlts+2,nSpecies)
  real, intent(in) :: LogINS(-1:nAlts+2,nIonsAdvect)
  real, intent(in) :: Vel_GD(-1:nAlts+2,3)
  real, intent(in) :: IVel(-1:nAlts+2,3)
  real, intent(in) :: Temp(-1:nAlts+2)
  real, intent(in) :: VertVel(-1:nAlts+2,nSpecies)
  real, intent(in) :: TempS(-1:nAlts+2,nSpecies)

  real, intent(inout) :: NewLogRho(-1:nAlts+2)
  real, intent(inout) :: NewLogNS(-1:nAlts+2,nSpecies)
  real, intent(inout) :: NewLogINS(-1:nAlts+2,nIonsAdvect)
  real, intent(inout) :: NewVel_GD(-1:nAlts+2,3)
  real, intent(inout) :: NewTemp(-1:nAlts+2)
  real, intent(inout) :: NewVertVel(-1:nAlts+2,nSpecies)
  real, intent(inout) :: NewTempS(-1:nAlts+2,nSpecies)

  integer :: iAlt, iSpecies, jSpecies, iDim

  real :: NS(-1:nAlts+2,nSpecies), Pressure1D(-1:nAlts+2)
  real :: Rho(-1:nAlts+2)

  real, dimension(1:nAlts)    :: DivVel, GradTmp, DiffTmp
  real, dimension(1:nAlts,1:nSpecies) :: DivVelS
  real, dimension(1:nAlts,1:nSpecies) :: GradVelS, DiffVelS
  real, dimension(1:nAlts,3) :: GradVel_CD, DiffVel_CD

  real, dimension(1:nAlts,nIonsAdvect) :: GradLogINS, DiffLogINS
  real :: NewSumRho, NewLogSumRho


!! Total Density and Pressure

  real, dimension(-1:nAlts+2)    :: NT
  real, dimension(-1:nAlts+2)    :: Press, LogPress


!!! Neutral Friction
  real :: nVel(-1:nAlts+2,1:nSpecies)
  real :: nTempS(-1:nAlts+2,1:nSpecies)
  real :: LogCon(-1:nAlts+2,1:nSpecies)
  real, dimension( 1:nAlts  ,nSpecies)    :: GradLogCon



  real :: RhoS(-1:nAlts+2,1:nSpecies),&
       NewRhoS(-1:nAlts+2,1:nSpecies),&
       LogRhoS(-1:nAlts+2,1:nSpecies),&
    NewLogRhoS(-1:nAlts+2,1:nSpecies), &
        AUSMRhoSFluxes(1:nAlts,1:nSpecies)

  real, dimension(-1:nAlts+2)    :: RadialDistance_C, &
                                    EffectiveGravity, &
                                    EffectiveGravity_NoCoriolis

  real :: MomentumS(-1:nAlts+2,1:nSpecies),&
          NewMomentumS(-1:nAlts+2,1:nSpecies),&
          Momentum(-1:nAlts+2,1:3),&
          NewMomentum(-1:nAlts+2,1:3),&
          HydroAUSMMomentumSFluxes(1:nAlts,1:nSpecies), &
          HydroAUSMMomentumFluxes(1:nAlts,3), &
          PressureS(-1:nAlts+2,1:nSpecies), &
          NewNS(-1:nAlts+2,1:nSpecies), &
          NewNT(-1:nAlts+2)


  real :: TotalEnergy(-1:nAlts+2),&
       NewTotalEnergy(-1:nAlts+2),&
       AUSMTotalEnergyNumFluxes(1:nAlts), &
       NewPress(-1:nAlts+2), NewRho(-1:nAlts+2)

  real :: TotalEnergyS(-1:nAlts+2,1:nSpecies),&
       NewTotalEnergyS(-1:nAlts+2,1:nSpecies),&
       StressHeatingS(-1:nAlts+2,1:nSpecies),&
       AUSMTotalEnergySNumFluxes(1:nAlts,1:nSpecies), &
       EnergyInteraction(-1:nAlts+2,1:nSpecies), &
       NewPressS(-1:nAlts+2,1:nSpecies), PressS(-1:nAlts+2)


  real :: InvScaleHeight, MeanGravity, MeanTemp, MeanMass
  real :: TimeFactor

  real ::   HydroNS(-1:nAlts+2,1:nSpecies),&
          HydroRhoS(-1:nAlts+2,1:nSpecies), &
            HydroNT(-1:nAlts+2),&
   TotalChemSources(-1:nAlts+2),&
     HydroPressureS(-1:nAlts+2,1:nSpecies),&
 DeviationPressureS(-1:nAlts+2,1:nSpecies),&
      DeviationRhoS(-1:nAlts+2,1:nSpecies),&
      HydroPressure(-1:nAlts+2), HydroRho(-1:nAlts+2), &
       DeviationRho(-1:nAlts+2)


     real :: NuSP(nAlts), Nu0, Ksp
  integer :: nAltsSponge, iAltSponge, AltSpongeBegin

  logical :: IsHydrostatic(nSpecies) 
  logical :: SubtractHydrostatic(-1:nAlts+2,1:nSpecies)   !!! Determines whether or not we use 

  !--------------------------------------------------------------------------
!!! Extract Rho, NT, NS, and Pressure (Press)
!!!! END THE HYDROSTATIC BACKGROUND CALCULATION

  IsHydrostatic = .true.


!!! These Species DO NOT have their background subtracted

  IsHydrostatic(iH_) = .false.
  IsHydrostatic(iH2_) = .false.
  IsHydrostatic(iN4S_) = .false.
  IsHydrostatic(iHCN_) = .false.
  IsHydrostatic(iC2H4_) = .false.

  nAltsSponge = 10            !!! thickness of the sponge
  AltSpongeBegin = nAlts-10   !!! Where the Sponge Begins

  do iAlt = 1, nAlts
     if (iAlt .gt. AltSpongeBegin) then
        iAltSponge = (nAlts - iAlt + 1)
        Nu0 = (0.5/(5.0*Dt))
        NuSP(iAlt) = Nu0*(1.0 - cos(PI*(nAltsSponge + 1 - iAltSponge)/nAltsSponge) )
     else
        NuSP(iAlt) = 0.0
     endif 
  enddo 

  do iAlt = -1, nAlts + 2
    RadialDistance_C(iAlt) = 1.0/InvRadialDistance_C(iAlt)
  enddo

  Rho = exp(LogRho)

  do iAlt = -1, nAlts + 2
     do iSpecies =  1, nSpecies
       NS(iAlt,iSpecies) = exp(LogNS(iAlt,iSpecies) )
     enddo 
  enddo

     NT = 0.0
     do iSpecies =  1, nSpecies
       NT(-1:nAlts+2) = NT(-1:nAlts+2) + &
         NS(-1:nAlts+2,iSpecies)
     enddo 

     TotalChemSources = 0.0

     do iSpecies =  1, nSpecies
       TotalChemSources(-1:nAlts+2) = &
          TotalChemSources(-1:nAlts+2) + &
            ChemSources_1d(-1:nAlts+2,iSpecies)*Mass(iSpecies)
     enddo 

     do iAlt = -1, nAlts + 2
        do iSpecies =  1, nSpecies
          LogCon(iAlt,iSpecies) = alog( NS(iAlt,iSpecies)/NT(iAlt))
          !LogCon(iAlt,iSpecies) = alog( NS(iAlt,iSpecies)/NS(iAlt,iN2_))
        enddo 
     enddo


  do iAlt = -1, nAlts + 2
    Press(iAlt) = NT(iAlt)*Boltzmanns_Constant*Temp(iAlt)
    LogPress(iAlt) = log(Press(iAlt))
  enddo

!!!!  BEGIN THE HYDROSTATIC BACKGROUND
    HydroNS(-1:nAlts+2,1:nSpecies) = NS(-1:nAlts+2,1:nSpecies)
    HydroNT(-1:nAlts+2) = NT(-1:nAlts+2)

     !!! Establish the Effective Gravity
         do iAlt = -1, nAlts + 2
 
!           EffectiveGravity(iAlt) = &
!              Gravity_G(iAlt) + & 
!              (Vel_GD(iAlt,iNorth_)**2 + Vel_GD(iAlt,iEast_)**2) &
!              *InvRadialDistance_C(iAlt) + &
!              Centrifugal/InvRadialDistance_C(iAlt) + &
!             Coriolis*Vel_GD(iAlt,iEast_)
!
!           EffectiveGravity_NoCoriolis(iAlt) = &
!              Gravity_G(iAlt) + & 
!              (Vel_GD(iAlt,iNorth_)**2 + Vel_GD(iAlt,iEast_)**2) &
!              *InvRadialDistance_C(iAlt) + &
!              Centrifugal/InvRadialDistance_C(iAlt) 
!
!
 
            EffectiveGravity(iAlt) = &
               Gravity_G(iAlt) + Centrifugal/InvRadialDistance_C(iAlt) 
 
 
         enddo


!        do iAlt = -1, nAlts + 2
!           EffectiveGravity(iAlt) = &
!              Gravity_G(iAlt) 
!        enddo
!
     !!! Begin With Cell 1 and Integrate upward (Leave Cell (0) alone)

         do iAlt = 1, nAlts + 2

           MeanMass = 0.5*(MeanMajorMass_1d(iAlt-1) + MeanMajorMass_1d(iAlt))

           MeanGravity = 0.5*( EffectiveGravity(iAlt) + EffectiveGravity(iAlt-1) )
           MeanTemp = 0.5*( Temp(iAlt) + Temp(iAlt-1) )

           InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                            (Boltzmanns_Constant*MeanTemp)

           HydroNT(iAlt) = HydroNT(iAlt-1)*(Temp(iAlt-1)/Temp(iAlt))*&
                 exp (-1.0*dAlt_F(iAlt)*InvScaleHeight)

        enddo 

          iAlt = -1

          MeanMass = 0.5*( MeanMajorMass_1d(-1) + MeanMajorMass_1d(0))
          MeanGravity = 0.5*( EffectiveGravity(iAlt+1) + EffectiveGravity(iAlt) )
             MeanTemp = 0.5*( Temp(iAlt+1) + Temp(iAlt) )

          InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                           (Boltzmanns_Constant*MeanTemp)

          HydroNT(iAlt) = HydroNT(iAlt+1)*(Temp(iAlt+1)/Temp(iAlt))*&
                exp(dAlt_F(iAlt)*InvScaleHeight)




!!!! The Old Species Way


      do iSpecies =  1, nSpecies

         do iAlt = 1, nAlts + 2
   
          MeanMass = Mass(iSpecies)

          MeanGravity = 0.5*( EffectiveGravity(iAlt) + EffectiveGravity(iAlt-1) )
          MeanTemp = 0.5*( TempS(iAlt,iSpecies) + TempS(iAlt-1,iSpecies) )
          !MeanTemp = 0.5*( Temp(iAlt) + Temp(iAlt-1) )

          InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                           (Boltzmanns_Constant*MeanTemp)

!          HydroNS(iAlt,iSpecies) = HydroNS(iAlt-1,iSpecies)*(Temp(iAlt-1)/Temp(iAlt))*&
!                exp (-1.0*dAlt_F(iAlt)*InvScaleHeight)

          HydroNS(iAlt,iSpecies) = HydroNS(iAlt-1,iSpecies)*(TempS(iAlt-1,iSpecies)/TempS(iAlt,iSpecies))*&
                exp (-1.0*dAlt_F(iAlt)*InvScaleHeight)

        enddo 
     enddo 


      do iSpecies =  1, nSpecies

         iAlt = -1

          MeanMass = 0.5*( MeanMajorMass_1d(-1) + MeanMajorMass_1d(0))
          MeanGravity = 0.5*( EffectiveGravity(iAlt+1) + EffectiveGravity(iAlt) )
          !MeanTemp = 0.5*( Temp(iAlt+1) + Temp(iAlt) )
          MeanTemp = 0.5*( TempS(iAlt+1,iSpecies) + TempS(iAlt,iSpecies) )

          InvScaleHeight = -1.0* MeanMass*MeanGravity/&
                           (Boltzmanns_Constant*MeanTemp)

!          HydroNS(iAlt,iSpecies) = HydroNS(iAlt+1,iSpecies)*(Temp(iAlt+1)/Temp(iAlt))*&
!                exp(dAlt_F(iAlt)*InvScaleHeight)

          HydroNS(iAlt,iSpecies) = HydroNS(iAlt+1,iSpecies)*(TempS(iAlt+1,iSpecies)/TempS(iAlt,iSpecies))*&
                exp(dAlt_F(iAlt)*InvScaleHeight)

     enddo 


     do iAlt = -1, nAlts + 2
        do iSpecies =  1, nSpecies

          !HydroPressureS(iAlt,iSpecies) = HydroNS(iAlt,iSpecies)*Boltzmanns_Constant*Temp(iAlt)
          HydroPressureS(iAlt,iSpecies) = HydroNS(iAlt,iSpecies)*Boltzmanns_Constant*TempS(iAlt,iSpecies)
          HydroRhoS(iAlt,iSpecies) = Mass(iSpecies)*HydroNS(iAlt,iSpecies)

        enddo 

          HydroPressure(iAlt) = HydroNT(iAlt)*Boltzmanns_Constant*Temp(iAlt)
               HydroRho(iAlt) = HydroNT(iAlt)*MeanMajorMass_1d(iAlt)
     enddo 




  do iSpecies = 1, nSpecies
     RhoS(-1:nAlts+2,iSpecies) =  &
        Mass(iSpecies)*NS(-1:nAlts+2,iSpecies)

     NewRhoS(-1:nAlts+2,iSpecies) = RhoS(-1:nAlts+2,iSpecies)

     MomentumS(-1:nAlts+2,iSpecies) =  &
        Mass(iSpecies)*NS(-1:nAlts+2,iSpecies)*&
         VertVel(-1:nAlts+2,iSpecies)

!     PressureS(-1:nAlts+2,iSpecies) =  &
!        NS(-1:nAlts+2,iSpecies)*Temp(-1:nAlts+2)*&
!        Boltzmanns_Constant

     PressureS(-1:nAlts+2,iSpecies) =  &
        NS(-1:nAlts+2,iSpecies)*TempS(-1:nAlts+2,iSpecies)*&
        Boltzmanns_Constant
  enddo 

  do iDim = 1, 3
     Momentum(-1:nAlts+2,iDim) = Rho(-1:nAlts+2)*Vel_GD(-1:nAlts+2,iDim)
  enddo 

!!!! Calculate Deviations between the GITM Fields and the Background State
    DeviationPressureS(-1:nAlts+2,1:nSpecies) = &
        PressureS(-1:nAlts+2,1:nSpecies) - HydroPressureS(-1:nAlts+2,1:nSpecies)

    DeviationRhoS(-1:nAlts+2,1:nSpecies) = &
        RhoS(-1:nAlts+2,1:nSpecies) - HydroRhoS(-1:nAlts+2,1:nSpecies)

    DeviationRho(-1:nAlts+2) = &
        Rho(-1:nAlts+2) - HydroRho(-1:nAlts+2)
!!! ==========================


  do iAlt = -1, nAlts + 2
    TotalEnergy(iAlt) = &
         Press(iAlt)/(Gamma_1d(iAlt) - 1.0) 

      do iSpecies = 1, nSpecies
        TotalEnergyS(iAlt,iSpecies) = &
             PressureS(iAlt,iSpecies)/(GammaS_1d(iAlt,iSpecies) - 1.0) 
      enddo 
  enddo 


    VS1D_HydrostaticPressureS(-1:nAlts+2,1:nSpecies) = & 
         HydroPressureS(-1:nAlts+2,1:nSpecies)

    VS1D_HydrostaticRhoS(-1:nAlts+2,1:nSpecies) = & 
         HydroRhoS(-1:nAlts+2,1:nSpecies)

    VS1D_DeviationPressureS(-1:nAlts+2,1:nSpecies) = & 
         (PressureS(-1:nAlts+2,1:nSpecies) - HydroPressureS(-1:nAlts+2,1:nSpecies))/&
          HydroPressureS(-1:nAlts+2,1:nSpecies)

    VS1D_DeviationRhoS(-1:nAlts+2,1:nSpecies) = & 
         (RhoS(-1:nAlts+2,1:nSpecies) - HydroRhoS(-1:nAlts+2,1:nSpecies))/&
          RhoS(-1:nAlts+2,1:nSpecies)

!  logical :: SubtractHydrostatic(-1:nAlts+2,1:nSpecies)   !!! Determines whether or not we use 

    do iAlt = -1, nAlts + 2
       do iSpecies = 1, nSpecies
             if ( abs(VS1D_DeviationRhoS(iAlt,iSpecies)) .gt. 1.0) then
                !!! This means that Rho - Rho(H) is > Rho (Too much Flux)
                SubtractHydrostatic(iAlt,iSpecies) = .false.
             else
                !!! This means that Rho - Rho(H) is < Rho. Subtract off Rho(H)
                SubtractHydrostatic(iAlt,iSpecies) = .true.
             endif 
       enddo 
    enddo 

!!! Initialize some key variables

  NewRho = Rho
  NewPress = Press
  NewTotalEnergy = TotalEnergy
  NewTotalEnergyS = TotalEnergyS


!  do iAlt = -1, nAlts + 2
!    do iSpecies = 1, nSpecies
!        if (   (VertVel(iAlt,iSpecies) .gt. 0.0 ) .and. (VertVel(iAlt,iSpecies) .lt. 0.0)) then
!            write(*,*) ' YOU JUST GOT NANNED'
!            write(*,*) 'VertVel = ', VertVel(iAlt,iSpecies), iAlt, cSpecies(iSpecies)
!        endif 
!
!    enddo 
!  enddo 


  call calc_all_fluxes_hydro(RhoS, PressureS, TotalEnergy, Press, HydroPressureS, HydroRhoS, &
                       HydroPressure,  HydroRho, AUSMRhoSFluxes,  HydroAUSMMomentumSFluxes, &
                      AUSMTotalEnergyNumFluxes, HydroAUSMMomentumFluxes, RadialDistance_C, &
                      IsHydrostatic, SubtractHydrostatic, TotalEnergyS, AUSMTotalEnergySNumFluxes)



  do iDim = 1, 3
     call calc_rusanov_alts(Vel_GD(:,iDim), &
          GradVel_CD(:,iDim),DiffVel_CD(:,iDim))
  enddo
  ! Add geometrical correction to gradient and obtain divergence
    DivVel = GradVel_CD(:,iUp_) + 2*Vel_GD(1:nAlts,iUp_)*InvRadialDistance_C(1:nAlts)

  do iSpecies = 1, nSpecies
     call calc_rusanov_alts(VertVel(:,iSpecies), &
          GradVelS(:,iSpecies),DiffVelS(:,iSpecies))

  ! Add geometrical correction to gradient and obtain divergence
    DivVelS(:,iSpecies) = GradVelS(:,iSpecies) + &
                           2*VertVel(1:nAlts,iSpecies)*InvRadialDistance_C(1:nAlts)
  enddo


  do iSpecies=1,nSpecies

     call calc_rusanov_alts(LogCon(:,iSpecies),GradTmp, DiffTmp)
     GradLogCon(:,iSpecies) = GradTmp

  enddo

  do iSpecies=1,nIonsAdvect
     call calc_rusanov_alts(LogINS(:,iSpecies), GradTmp, DiffTmp)
     GradLogINS(:,iSpecies) = GradTmp
     DiffLogINS(:,iSpecies) = DiffTmp
  enddo


!!!!! Begin Eddy Velocity Calculations =========================================================


   do iSpecies = 1, nSpecies
      VS1D_GradLogCon(1:nAlts,iSpecies) = GradLogCon(1:nAlts,iSpecies)
      VS1D_GradLogCon(0,iSpecies) = GradLogCon(0,iSpecies)
      VS1D_GradLogCon(-1,iSpecies) = GradLogCon(-1,iSpecies)
      VS1D_GradLogCon(nAlts+1,iSpecies) = GradLogCon(nAlts,iSpecies)
      VS1D_GradLogCon(nAlts+2,iSpecies) = GradLogCon(nAlts,iSpecies)

      VS1D_EddyVelocity(-1:nAlts+2,iSpecies) = -1.0*EddyCoef_1d(-1:nAlts+2)*GradLogCon(-1:nAlts+2,iSpecies)
   enddo 

  do iAlt = 1,nAlts
     do iSpecies=1,nSpecies

           NewRhoS(iAlt,iSpecies) = RhoS(iAlt,iSpecies) &
                  - Dt*(InvRadialDistance_C(iAlt)**2.0)*(AUSMRhoSFluxes(iAlt,iSpecies))

           NewLogNS(iAlt,iSpecies) = log( NewRhoS(iAlt,iSpecies)/Mass(iSpecies) )
 
     enddo

     do iSpecies=1,nIonsAdvect
        NewLogINS(iAlt,iSpecies) = LogINS(iAlt,iSpecies) - Dt * &
             (IVel(iAlt,iUp_) * GradLogINS(iAlt,iSpecies) ) &
             + Dt * DiffLogINS(iAlt,iSpecies)*1.00
     enddo

  enddo !iAlt = 1,nAlts



   NewNS  = 0.0
   NewNT  = 0.0
   NewRho = 0.0

   do iAlt = -1, nAlts+2

      do iSpecies = 1, nSpecies
          NewNS(iAlt,iSpecies) = NewRhoS(iAlt,iSpecies)/Mass(iSpecies)

          NewRho(iAlt) = NewRho(iAlt) + &
                   NewRhoS(iAlt,iSpecies)

          NewNT(iAlt) = NewNT(iAlt) + &
                NewNS(iAlt,iSpecies)
            
      enddo 

   enddo 

  do iAlt = 1,nAlts


     do iSpecies=1,nSpecies


!           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
!                 Dt*(InvRadialDistance_C(iAlt)**2.0)*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*Gravity_G(iAlt) + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*(Vel_GD(iAlt,iNorth_)**2 + Vel_GD(iAlt,iEast_)**2) &
!                 * InvRadialDistance_C(iAlt) + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*Centrifugal/InvRadialDistance_C(iAlt) + &
!                 Dt*2.0*DeviationPressureS(iAlt,iSpecies)*InvRadialDistance_C(iAlt)  + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*Coriolis*Vel_GD(iAlt,iEast_)




!           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
!                 Dt*(InvRadialDistance_C(iAlt)**2.0)*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*Gravity_G(iAlt) + &
!                 Dt*2.0*DeviationPressureS(iAlt,iSpecies)*InvRadialDistance_C(iAlt) + &  
!                 Dt*DeviationRhoS(iAlt,iSpecies)*(Vel_GD(iAlt,iNorth_)**2 + Vel_GD(iAlt,iEast_)**2) &
!                 * InvRadialDistance_C(iAlt) + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*Centrifugal/InvRadialDistance_C(iAlt) + &
!                 Dt*DeviationRhoS(iAlt,iSpecies)*Coriolis*Vel_GD(iAlt,iEast_)


           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
                 Dt*(InvRadialDistance_C(iAlt)**2.0)*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
                 Dt*DeviationRhoS(iAlt,iSpecies)*EffectiveGravity(iAlt) + &
                 Dt*2.0*DeviationPressureS(iAlt,iSpecies)*InvRadialDistance_C(iAlt) 

           if (SubtractHydrostatic(iAlt,iSpecies) .eq. .false.) then

!           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
!                 Dt*(InvRadialDistance_C(iAlt)**2.0)*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
!                 Dt*RhoS(iAlt,iSpecies)*Gravity_G(iAlt) + &
!                 Dt*2.0*PressureS(iAlt,iSpecies)*InvRadialDistance_C(iAlt) + &  
!                 Dt*RhoS(iAlt,iSpecies)*(Vel_GD(iAlt,iNorth_)**2 + Vel_GD(iAlt,iEast_)**2) &
!                 * InvRadialDistance_C(iAlt) + &
!                 Dt*RhoS(iAlt,iSpecies)*Centrifugal/InvRadialDistance_C(iAlt) + &
!                 Dt*RhoS(iAlt,iSpecies)*Coriolis*Vel_GD(iAlt,iEast_)

           NewMomentumS(iAlt,iSpecies) = MomentumS(iAlt,iSpecies) - &
                 Dt*(InvRadialDistance_C(iAlt)**2.0)*(HydroAUSMMomentumSFluxes(iAlt,iSpecies)) + &
                 Dt*RhoS(iAlt,iSpecies)*EffectiveGravity(iAlt) + &
                 Dt*2.0*PressureS(iAlt,iSpecies)*InvRadialDistance_C(iAlt) 
                
           endif 

           NewMomentumS(iAlt,iSpecies) = NewMomentumS(iAlt,iSpecies) + &
                 Dt*ChemSources_1d(iAlt,iSpecies)*VertVel(iAlt,iSpecies)*Mass(iSpecies)

           NewVertVel(iAlt,iSpecies) = NewMomentumS(iAlt,iSpecies)/NewRhoS(iAlt,iSpecies) - &
                                                      Dt*NuSP(iAlt)*VertVel(iAlt,iSpecies)

!           NewVertVel(iAlt,iSpecies) = NewMomentumS(iAlt,iSpecies)/NewRhoS(iAlt,iSpecies) 


     enddo

  enddo



!!!! Use this for the Fully Implicit Implementation
 
  do iAlt = -1, nAlts + 2
    do iSpecies = 1, nSpecies
        if (   (NewVertVel(iAlt,iSpecies) .gt. 0.0 ) .and. (NewVertVel(iAlt,iSpecies) .lt. 0.0)) then
            write(*,*) ' YOU JUST GOT NANNED'
            write(*,*) 'NewVertVel = ', NewVertVel(iAlt,iSpecies), iAlt, cSpecies(iSpecies)
        endif 

    enddo 
  enddo 
 
                 nVel(-1:nAlts+2,1:nSpecies) = NewVertVel(-1:nAlts+2,1:nSpecies)

                 call calc_neutral_friction(   nVel(-1:nAlts+2,1:nSpecies), &
                                        EddyCoef_1d(-1:nAlts+2), &
                                              NewNT(-1:nAlts+2), &
                                              NewNS(-1:nAlts+2,1:nSpecies), &
                                         GradLogCon(-1:nAlts+2,1:nSpecies), &
                                               Temp(-1:nAlts+2) )

                 NewVertVel(1:nAlts, 1:nSpecies) = nVel(1:nAlts, 1:nSpecies) 


!                 call calc_energy_integral(NewVertVel(-1:nAlts+2,1:nSpecies), &
!                                     EddyCoef_1d(-1:nAlts+2), &
!                                              NewNT(-1:nAlts+2), &
!                                              NewNS(-1:nAlts+2,1:nSpecies), &
!                                       GradLogCon(-1:nAlts+2,1:nSpecies), &
!                                            Temp(-1:nAlts+2), &
!                                            TempS(-1:nAlts+2,1:nSpecies), &
!                                        EnergyInteraction(-1:nAlts+2,1:nSpecies) )


 
  do iAlt = -1, nAlts + 2
    do iSpecies = 1, nSpecies
        if (   (NewVertVel(iAlt,iSpecies) .gt. 0.0 ) .and. (NewVertVel(iAlt,iSpecies) .lt. 0.0)) then
            write(*,*) ' YOU JUST GOT NANNED'
            write(*,*) 'NewVertVel = ', NewVertVel(iAlt,iSpecies), iAlt, cSpecies(iSpecies)
        endif 

    enddo 
  enddo 

!!!! Use this for the Fully Implicit Implementation


  do iAlt = 1, nAlts
     do iSpecies=1,nSpecies
            NewVertVel(iAlt, iSpecies) = max(-MaximumVerticalVelocity, NewVertVel(iAlt, iSpecies))
            NewVertVel(iAlt, iSpecies) = min( MaximumVerticalVelocity, NewVertVel(iAlt, iSpecies))
         if (iSpecies .eq. iH2_) then
            NewVertVel(iAlt, iSpecies) = max(-75.0, NewVertVel(iAlt, iSpecies))
            NewVertVel(iAlt, iSpecies) = min( 75.0, NewVertVel(iAlt, iSpecies))

         elseif(iSpecies .eq. iH_) then
            NewVertVel(iAlt, iSpecies) = max(-MaximumVerticalVelocity, NewVertVel(iAlt, iSpecies))
            NewVertVel(iAlt, iSpecies) = min( MaximumVerticalVelocity, NewVertVel(iAlt, iSpecies))
         else  !!! All Other Species
!!! This is used for a Cold Start of the model... allows it to "spin up"
            TimeFactor = exp(-tSimulation/(86400.0*15.94*4.0))
            NewVertVel(iAlt, iSpecies) = max(-10.0*(1.0 - TimeFactor), NewVertVel(iAlt, iSpecies))
            NewVertVel(iAlt, iSpecies) = min( 10.0*(1.0 - TimeFactor), NewVertVel(iAlt, iSpecies))
         endif
     enddo 
  enddo 


  do iAlt = -1, nAlts+2
        NewVel_GD(iAlt,iUp_) = 0.0
     do iSpecies=1,nSpecies
        NewVel_GD(iAlt,iUp_) = NewVel_GD(iAlt,iUp_) + &
             NewVertVel(iAlt, iSpecies) * &
             (Mass(iSpecies) * NewNS(iAlt,iSpecies) / NewRho(iAlt))

     enddo
  enddo


  do iAlt = 1, nAlts

     ! dVphi/dt = - (V grad V)_phi
         NewMomentum(iAlt,iEast_) = Momentum(iAlt,iEast_) - Dt* &
            (InvRadialDistance_C(iAlt)**2.0)*HydroAUSMMomentumFluxes(iAlt,iEast_)
 
        NewVel_GD(iAlt,iEast_) = NewMomentum(iAlt,iEast_)/NewRho(iAlt)
 
     ! dVtheta/dt = - (V grad V)_theta
       NewMomentum(iAlt,iNorth_) = Momentum(iAlt,iNorth_) - Dt* &
           (InvRadialDistance_C(iAlt)**2.0)*HydroAUSMMomentumFluxes(iAlt,iNorth_)
 
       NewVel_GD(iAlt,iNorth_) = NewMomentum(iAlt,iNorth_)/NewRho(iAlt)



     ! dT/dt = -(V.grad T + (gamma - 1) T div V +  &
     !        (gamma - 1) * g  * grad (KeH^2  * rho) /rho 
        do iSpecies = 1, nSpecies

          NewTotalEnergyS(iAlt,iSpecies) =   TotalEnergyS(iAlt,iSpecies) - &
              Dt*(InvRadialDistance_C(iAlt)**2.0)*AUSMTotalEnergySNumFluxes(iAlt,iSpecies) - & 
              Dt*DivVelS(iAlt,iSpecies)*PressureS(iAlt,iSpecies)


!          NewTotalEnergyS(iAlt,iSpecies) =   NewTotalEnergyS(iAlt,iSpecies) + &
!             Dt*ViscCoef_1d(iAlt)*( (4.0/3.0)*GradVelS(iAlt,iSpecies)**2.0 + &
!                                             GradVel_CD(iAlt,iNorth_)**2.0 + &
!                                              GradVel_CD(iAlt,iEast_)**2.0)

          NewPressS(iAlt,iSpecies) = &
             NewTotalEnergyS(iAlt,iSpecies)*(GammaS_1d(iAlt,iSpecies) - 1.0)

          NewTempS(iAlt,iSpecies) = NewPressS(iAlt,iSpecies)/(Boltzmanns_Constant*NewNS(iAlt,iSpecies))

        enddo ! iSpecies
  enddo !! iAlt


!!! Add this after the fluid advection step
!!! Add Energy "Collisional Terms"

                            nTempS(-1:nAlts+2, 1:nSpecies) = NewTempS(-1:nAlts+2,1:nSpecies)
                 EnergyInteraction(-1:nAlts+2, 1:nSpecies) = NewTempS(-1:nAlts+2,1:nSpecies)

                 call calc_energy_integral(NewVertVel(-1:nAlts+2,1:nSpecies), &
                                     EddyCoef_1d(-1:nAlts+2), &
                                              NewNT(-1:nAlts+2), &
                                              NewNS(-1:nAlts+2,1:nSpecies), &
                                       GradLogCon(-1:nAlts+2,1:nSpecies), &
                                            Temp(-1:nAlts+2), &
                                            nTempS(-1:nAlts+2,1:nSpecies), &
                                        EnergyInteraction(-1:nAlts+2,1:nSpecies), &
                                        GammaS_1d(-1:nAlts+2,1:nSpecies))

                 NewTempS(1:nAlts,1:nSpecies) = EnergyInteraction(1:nAlts,1:nSpecies)

        NewTemp(-1:nAlts+2) = 0.0
    do iSpecies = 1, nSpecies
        NewTemp(-1:nAlts+2) = NewTemp(-1:nAlts+2) + &
            (NewNS(-1:nAlts+2,iSpecies)/NewNT(-1:nAlts+2))*NewTempS(-1:nAlts+2,iSpecies)
    enddo 


  do iAlt = 1, nAlts
     NewSumRho    = sum( Mass(1:nSpecies)*exp(NewLogNS(iAlt,1:nSpecies)) )
     NewLogRho(iAlt) = log(NewSumRho)
  enddo


end subroutine advance_vertical_1stage

!\
! ------------------------------------------------------------
! calc_rusanov
! ------------------------------------------------------------
!/

subroutine calc_rusanov_alts(Var, GradVar, DiffVar)

  use ModSizeGitm
  use ModVertical, only : dAlt_C, cMax
  implicit none

  real, intent(in) :: Var(-1:nAlts+2)
  real, intent(out):: GradVar(1:nAlts), DiffVar(1:nAlts)

  real, dimension(1:nAlts+1) :: VarLeft, VarRight, DiffFlux
  integer :: iAlt

  !------------------------------------------------------------

!!!!! OLD METHOD
 
    call calc_facevalues_alts(Var, VarLeft, VarRight)
   
     GradVar = 0.5 * &
          (VarLeft(2:nAlts+1)+VarRight(2:nAlts+1) - &
          VarLeft(1:nAlts)-VarRight(1:nAlts))/dAlt_C(1:nAlts)
   
   
     DiffFlux = 0.50 * max(cMax(0:nAlts),cMax(1:nAlts+1)) * (VarRight - VarLeft)
   
     DiffVar = (DiffFlux(2:nAlts+1) - DiffFlux(1:nAlts))/dAlt_C(1:nAlts)
   
end subroutine calc_rusanov_alts

!\
! ------------------------------------------------------------
! calc_facevalues_alts
! ------------------------------------------------------------
!/



 subroutine calc_facevalues_alts(Var, VarLeft, VarRight)
 
   use ModVertical, only: dAlt_F, InvDAlt_F
   use ModSizeGITM, only: nAlts
   use ModLimiterGitm
 
   implicit none
   
   real, intent(in) :: Var(-1:nAlts+2)
   real, intent(out):: VarLeft(1:nAlts+1), VarRight(1:nAlts+1)
 
   real :: dVarUp, dVarDown, dVarLimited(0:nAlts+1)
 
   real, parameter :: Factor1=0.6250000 ! 15/24
   real, parameter :: Factor2=0.0416667 !  1/24
   real :: h
 
   integer :: i
 
   do i=1,nAlts
 
      ! 4th order scheme for calculating face values
 
        h  = InvDAlt_F(i+1)*2.0
        dVarUp   = h*(Factor1*(Var(i+1)-Var(i)  ) - Factor2*(Var(i+2)-Var(i-1)))
        h  = InvDAlt_F(i)*2.0
        dVarDown = h*(Factor1*(Var(i)  -Var(i-1)) - Factor2*(Var(i+1)-Var(i-2)))
 
       ! This is Gabor's scheme
        dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
        dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)

      dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)
 
 
   end do
 
   i = 0
   dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
   dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)
   dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)
 
   i = nAlts+1
   dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
   dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)
   dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)
 
   do i=1,nAlts+1
      VarLeft(i)  = Var(i-1) + 0.5*dVarLimited(i-1) * dAlt_F(i-1)
      VarRight(i) = Var(i)   - 0.5*dVarLimited(i)   * dAlt_F(i)
   end do
 
 end subroutine calc_facevalues_alts
 



subroutine calc_all_fluxes_hydro(RhoS, PressureS, Energy, Pressure_1D, HydroPressureS, HydroRhoS, &
                                 HydroPressure, HydroRho, RhoSFlux, MomentumSFlux, EnergyFluxes, &
                                 MomentumFluxes, RadDist, IsHydrostatic, SubtractHydrostatic, &
                                 EnergyS, EnergySFluxes)



  use ModSizeGitm
  use ModVertical, only : dAlt_C, cMax, VertVel, Gamma_1d, &
                          GammaS_1d, &
                          LogRho, Vel_GD, MeanMajorMass_1d, &
                          Temp, VS1D_TotalRhoFluxes, Altitude_G


  use ModPlanet, only : nSpecies, Mass, iCH4_, iN2_, iH2_, iH_, iAr_, i15N2_
  use ModGITM, only : iUp_, iEast_, iNorth_, Dt
  use ModConstants, only : Boltzmanns_Constant

  implicit none

  real, intent(in) :: RhoS(-1:nAlts+2, 1:nSpecies), PressureS(-1:nAlts+2,1:nSpecies)
  real, intent(in) :: HydroRhoS(-1:nAlts+2, 1:nSpecies), HydroPressureS(-1:nAlts+2,1:nSpecies)
  real, intent(in) :: HydroRho(-1:nAlts+2), HydroPressure(-1:nAlts+2)
  real, intent(in) :: Energy(-1:nAlts+2)
  real, intent(in) :: Pressure_1D(-1:nAlts+2)
  real, intent(out):: RhoSFlux(1:nAlts,1:nSpecies), MomentumSFlux(1:nAlts,1:nSpecies)
  real, intent(out) :: EnergyFluxes(1:nAlts)
  real, intent(out) :: MomentumFluxes(1:nAlts,3)
  real, intent(in) :: RadDist(-1:nAlts+2)
  logical, intent(in) :: IsHydrostatic(1:nSpecies)
  logical, intent(in) :: SubtractHydrostatic(-1:nAlts+2,1:nSpecies)
  real, intent(in) :: EnergyS(-1:nAlts+2,1:nSpecies)
  real, intent(out) :: EnergySFluxes(1:nAlts,1:nSpecies)



  real, dimension(1:nAlts,1:nSpecies) :: RhoSLeft_M12, RhoSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: RhoSLeft_P12, RhoSRight_P12

  real, dimension(-1:nAlts+2, 1:nSpecies) :: LogRhoS
  real, dimension(-1:nAlts+2, 1:nSpecies) :: LogPS

  real, dimension(1:nAlts,1:nSpecies) :: LogRhoSLeft_M12, LogRhoSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogRhoSLeft_P12, LogRhoSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: PressureSLeft_M12, PressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: PressureSLeft_P12, PressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: LogPressureSLeft_M12, LogPressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogPressureSLeft_P12, LogPressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: VelLeft_M12, VelRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: VelLeft_P12, VelRight_P12

  real, dimension(1:nAlts,3) :: VelGDLeft_M12, VelGDRight_M12
  real, dimension(1:nAlts,3) :: VelGDLeft_P12, VelGDRight_P12

  real, dimension(1:nAlts) :: PLeft_M12, PRight_M12
  real, dimension(1:nAlts) :: PLeft_P12, PRight_P12

  real, dimension(1:nAlts) :: LogPLeft_M12, LogPRight_M12
  real, dimension(1:nAlts) :: LogPLeft_P12, LogPRight_P12

  real, dimension(1:nAlts) :: GammaLeft_M12, GammaRight_M12
  real, dimension(1:nAlts) :: GammaLeft_P12, GammaRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: GammaSLeft_M12, GammaSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: GammaSLeft_P12, GammaSRight_P12

  real, dimension(1:nAlts) :: ELeft_M12, ERight_M12
  real, dimension(1:nAlts) :: ELeft_P12, ERight_P12

  real, dimension(1:nAlts,1:nSpecies) :: ESLeft_M12, ESRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: ESLeft_P12, ESRight_P12

  real, dimension(1:nAlts) :: RhoLeft_M12, RhoRight_M12
  real, dimension(1:nAlts) :: RhoLeft_P12, RhoRight_P12

  real, dimension(1:nAlts) :: LogRhoLeft_M12, LogRhoRight_M12
  real, dimension(1:nAlts) :: LogRhoLeft_P12, LogRhoRight_P12

  real, dimension(1:nAlts) :: CSLeft_M12, CSRight_M12
  real, dimension(1:nAlts) :: CSLeft_P12, CSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: RhoSFlux_M12, RhoSFlux_P12
  real, dimension(1:nAlts,1:nSpecies) :: MomentumSFlux_M12, MomentumSFlux_P12
  real, dimension(1:nAlts,3) :: Momentum_M12, Momentum_P12

  real, dimension(1:nAlts) :: EnergyFlux_M12, EnergyFlux_P12
  real, dimension(1:nAlts,1:nSpecies) :: EnergySFlux_M12, EnergySFlux_P12
  real, dimension(1:nAlts) :: VelocityEnergyFlux

!!! Hydrostatic Variables
  real, dimension(-1:nAlts+2,1:nSpecies) :: LogHydroPressureS
  real, dimension(-1:nAlts+2,1:nSpecies) :: LogHydroRhoS

  real, dimension(1:nAlts,1:nSpecies) :: LogHydroPressureSLeft_M12, LogHydroPressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogHydroPressureSLeft_P12, LogHydroPressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: LogHydroRhoSLeft_M12, LogHydroRhoSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: LogHydroRhoSLeft_P12, LogHydroRhoSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: HydroPressureSLeft_M12, HydroPressureSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: HydroPressureSLeft_P12, HydroPressureSRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: MeanHydroPressureS_M12
  real, dimension(1:nAlts,1:nSpecies) :: MeanHydroPressureS_P12

  real, dimension(1:nAlts,1:nSpecies) :: HydroRhoSLeft_M12, HydroRhoSRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: HydroRhoSLeft_P12, HydroRhoSRight_P12



!!!! ============ Mean Hydrostatic Variables (For Energy Calculation) ======= 

  real, dimension(-1:nAlts+2) :: LogHydroPressure
  real, dimension(-1:nAlts+2) :: LogHydroRho

  real, dimension(1:nAlts) :: LogHydroPressureLeft_M12, LogHydroPressureRight_M12
  real, dimension(1:nAlts) :: LogHydroPressureLeft_P12, LogHydroPressureRight_P12

  real, dimension(1:nAlts) :: LogHydroRhoLeft_M12, LogHydroRhoRight_M12
  real, dimension(1:nAlts) :: LogHydroRhoLeft_P12, LogHydroRhoRight_P12

  real, dimension(1:nAlts) :: HydroPressureLeft_M12, HydroPressureRight_M12
  real, dimension(1:nAlts) :: HydroPressureLeft_P12, HydroPressureRight_P12

  real, dimension(1:nAlts) :: MeanHydroPressure_M12, MeanHydroPressure_P12

  real, dimension(1:nAlts) :: HydroRhoLeft_M12, HydroRhoRight_M12
  real, dimension(1:nAlts) :: HydroRhoLeft_P12, HydroRhoRight_P12
  real :: SubCs
  integer :: iSpecies, iAlt, iDim
  !------------------------------------------------------------

  ! ==================== AUSM Flux Variables

  real, dimension( 1:nAlts,1:nSpecies) :: NumericalVelocity_P12, NumericalVelocity_M12    ! Interface velocities
  real, dimension( 1:nAlts,1:nSpecies) :: NumericalPressure_P12, NumericalPressure_M12    ! Interface velocities

  real, dimension( 1:nAlts) :: BulkNumericalVelocity_P12, BulkNumericalVelocity_M12    ! Interface velocities
  real, dimension( 1:nAlts) :: HorizBulkNumericalVelocity_P12, HorizBulkNumericalVelocity_M12    ! Interface velocities
  real, dimension( 1:nAlts) :: MeanCS_P12, MeanCS_M12    ! Interface velocities
  real, dimension( 1:nAlts, 1:nSpecies) :: MeanPressureS_P12, MeanPressureS_M12    ! Interface velocities
  real, dimension( 1:nAlts, 1:nSpecies) :: MeanRhoS_P12, MeanRhoS_M12    ! Interface velocities
  real, dimension( 1:nAlts) :: MeanRho_P12, MeanRho_M12    ! Interface velocities
  real :: Kp(1:nSpecies), Ku(1:nAlts,1:nSpecies)
  real :: LiouKp, LiouKu

  real :: LiouKpS(1:nAlts,1:nSpecies), LiouKuS(1:nAlts,1:nSpecies)
  real :: MaxKpS(1:nAlts,1:nSpecies), MaxKuS(1:nAlts,1:nSpecies)
  real :: MinKpS(1:nAlts,1:nSpecies), MinKuS(1:nAlts,1:nSpecies)
  real :: KpWidth
  integer :: AltIndex

  real, dimension( 1:nAlts) :: LeftRadius, RightRadius    ! RadialDistances of Face Values

!!!!!! ============================  Liou Stuff =======================================
  real :: LiouSubCs
  real, dimension(1:nAlts) :: LiouCSLeft_M12, LiouCSRight_M12
  real, dimension(1:nAlts) :: LiouCSLeft_P12, LiouCSRight_P12

  real, dimension(1:nAlts) :: LiouEnthalpyLeft_M12, LiouEnthalpyRight_M12
  real, dimension(1:nAlts) :: LiouEnthalpyLeft_P12, LiouEnthalpyRight_P12

  real, dimension(1:nAlts) :: InterfaceCS_M12, InterfaceCS_P12

  real, dimension(1:nAlts,1:nSpecies) :: MLeft_M12, MRight_M12
  real, dimension(1:nAlts,1:nSpecies) :: MLeft_P12, MRight_P12

  real, dimension(1:nAlts,1:nSpecies) :: M2Bar_M12, M2Bar_P12
  real, dimension(1:nAlts,1:nSpecies) :: M2Zero_M12, M2Zero_P12

  real, dimension(1:nAlts,1:nSpecies) :: MZero_M12, MZero_P12
  real:: MInf, LiouBeta
  real, dimension(1:nAlts,1:nSpecies):: ModifiedZeta

  real, dimension(1:nAlts,1:nSpecies) :: FA_M12, FA_P12
  real, dimension(1:nAlts,1:nSpecies) :: LiouAlpha_M12, LiouAlpha_P12

!!! Polynomial Mach Functions

!!! First Order Polynomial
  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Left_M12, MF1N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Right_M12, MF1N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Left_P12, MF1N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: MF1P_Right_P12, MF1N_Right_P12

!!!! 2nd Order Polynomial
  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Left_M12, MF2N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Right_M12, MF2N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Left_P12, MF2N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: MF2P_Right_P12, MF2N_Right_P12

!!!! 4th Order Polynomial
  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Left_M12, MF4N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Right_M12, MF4N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Left_P12, MF4N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: MF4P_Right_P12, MF4N_Right_P12

!!!! 5th Order Polynomial (Used only In Pressure Fluxes)
  real, dimension(1:nAlts,1:nSpecies) :: PF5P_Left_M12, PF5N_Left_M12
  real, dimension(1:nAlts,1:nSpecies) :: PF5P_Right_M12, PF5N_Right_M12

  real, dimension(1:nAlts,1:nSpecies) :: PF5P_Left_P12, PF5N_Left_P12
  real, dimension(1:nAlts,1:nSpecies) :: PF5P_Right_P12, PF5N_Right_P12

!!!! Pressure Mach Number
  real, dimension(1:nAlts,1:nSpecies) :: MPress_M12, MPress_P12
  real, dimension(1:nAlts,1:nSpecies) :: PU_M12, PU_P12

!!!! Interface Mach Number
  real, dimension(1:nAlts,1:nSpecies) :: InterfaceMach_M12, InterfaceMach_P12
  real, dimension(1:nAlts,1:nSpecies) :: InterfacePressure_M12, InterfacePressure_P12
  real, dimension(1:nAlts,1:nSpecies) :: LiouNumericalVelocity_M12, LiouNumericalVelocity_P12

!!! Extract Mean Atmosphere Values

  real :: LogKpS(1:nAlts,1:nSpecies), LogKuS(1:nAlts,1:nSpecies)
  real :: LogMinKpS(1:nAlts,1:nSpecies), LogMinKuS(1:nAlts,1:nSpecies)
  real :: LogMaxKpS(1:nAlts,1:nSpecies), LogMaxKuS(1:nAlts,1:nSpecies)


 MInf = 1.0e-19
 LiouBeta = 1.0/8.0

 LiouKp = 1.0e-09
 LiouKpS(1:nAlts,1:nSpecies) = 1.0e-09

 LogRhoS(-1:nAlts+2,1:nSpecies) = alog(RhoS(-1:nAlts+2,1:nSpecies))
 LogPS(-1:nAlts+2,1:nSpecies) = alog(PressureS(-1:nAlts+2,1:nSpecies))

 LogHydroRhoS(-1:nAlts+2,1:nSpecies) = alog(HydroRhoS(-1:nAlts+2,1:nSpecies))
 LogHydroPressureS(-1:nAlts+2,1:nSpecies) = alog(HydroPressureS(-1:nAlts+2,1:nSpecies))

 LogHydroRho(-1:nAlts+2) = alog(HydroRho(-1:nAlts+2))
 LogHydroPressure(-1:nAlts+2) = alog(HydroPressure(-1:nAlts+2))

 Kp(1:nSpecies) = 1.00             !! Ullrich et al. [2011]

 Ku(1:nAlts,1:nSpecies) = 2.0             !! Ullrich et al. [2011]


  LiouKu = 1.0
  LiouKp = 1.0e-19

  MinKuS(1:nAlts,1:nSpecies) = LiouKu
  MaxKuS(1:nAlts,1:nSpecies) = 1.0

  MinKpS(1:nAlts,1:nSpecies) = LiouKp
  MaxKpS(1:nAlts,1:nSpecies) = 1.0e-09


  LogMaxKuS = alog(MaxKuS)
  LogMinKuS = alog(MinKuS)

  LogMaxKpS = alog(MaxKpS)
  LogMinKpS = alog(MinKpS)


!!! Version on 01/23/2013 that looked (OK), but had choppy winds
   KpWidth = 100.0e+03
   AltIndex = 1
 
  do iAlt = 1, nAlts
 
          do iSpecies = 1, nSpecies
 
                 LogKpS(iAlt,iSpecies) = LogMinKpS(iAlt,iSpecies) +  0.5*(LogMaxKpS(iAlt,iSpecies) - LogMinKpS(iAlt,iSpecies))*( 1.0 + tanh(  (Altitude_G(iAlt) - Altitude_G(AltIndex))/KpWidth ) )
                 LogKuS(iAlt,iSpecies) = LogMinKuS(iAlt,iSpecies) +  0.5*(LogMaxKuS(iAlt,iSpecies) - LogMinKuS(iAlt,iSpecies))*( 1.0 + tanh(  (Altitude_G(iAlt) - Altitude_G(AltIndex))/KpWidth ) )

                LiouKpS(iAlt,iSpecies) = exp(LogKpS(iAlt,iSpecies))
                     Ku(iAlt,iSpecies) = exp(LogKuS(iAlt,iSpecies))
                 
          enddo 
 
  enddo 






!!!! Grab the left and right states of the Variables on boh Interfaces (P12 = +1/2 and M12 = -1/2)
    do iSpecies = 1, nSpecies
          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogRhoS(-1:nAlts+2,iSpecies), LogRhoSLeft_M12(1:nAlts,iSpecies), LogRhoSRight_M12(1:nAlts,iSpecies), &
                                                                 LogRhoSLeft_P12(1:nAlts,iSpecies), LogRhoSRight_P12(1:nAlts,iSpecies) )

           RhoSLeft_M12(:,iSpecies) = exp( LogRhoSLeft_M12(:,iSpecies)) 
          RhoSRight_M12(:,iSpecies) = exp(LogRhoSRight_M12(:,iSpecies)) 

           RhoSLeft_P12(:,iSpecies) = exp( LogRhoSLeft_P12(:,iSpecies)) 
          RhoSRight_P12(:,iSpecies) = exp(LogRhoSRight_P12(:,iSpecies)) 

    enddo 


    do iSpecies = 1, nSpecies
          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogHydroRhoS(-1:nAlts+2,iSpecies), LogHydroRhoSLeft_M12(1:nAlts,iSpecies), LogHydroRhoSRight_M12(1:nAlts,iSpecies), &
                                                                      LogHydroRhoSLeft_P12(1:nAlts,iSpecies), LogHydroRhoSRight_P12(1:nAlts,iSpecies) )

           HydroRhoSLeft_M12(:,iSpecies) = exp( LogHydroRhoSLeft_M12(:,iSpecies)) 
          HydroRhoSRight_M12(:,iSpecies) = exp(LogHydroRhoSRight_M12(:,iSpecies)) 

           HydroRhoSLeft_P12(:,iSpecies) = exp( LogHydroRhoSLeft_P12(:,iSpecies)) 
          HydroRhoSRight_P12(:,iSpecies) = exp(LogHydroRhoSRight_P12(:,iSpecies)) 

    enddo 

          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogHydroRho(-1:nAlts+2), LogHydroRhoLeft_M12(1:nAlts), LogHydroRhoRight_M12(1:nAlts), &
                                                            LogHydroRhoLeft_P12(1:nAlts), LogHydroRhoRight_P12(1:nAlts) )

           HydroRhoLeft_M12(:) = exp( LogHydroRhoLeft_M12(:)) 
          HydroRhoRight_M12(:) = exp(LogHydroRhoRight_M12(:)) 

           HydroRhoLeft_P12(:) = exp( LogHydroRhoLeft_P12(:)) 
          HydroRhoRight_P12(:) = exp(LogHydroRhoRight_P12(:)) 

!  


    do iSpecies = 1, nSpecies
          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogHydroPressureS(-1:nAlts+2,iSpecies), LogHydroPressureSLeft_M12(1:nAlts,iSpecies), LogHydroPressureSRight_M12(1:nAlts,iSpecies), &
                                                                           LogHydroPressureSLeft_P12(1:nAlts,iSpecies), LogHydroPressureSRight_P12(1:nAlts,iSpecies) )

           HydroPressureSLeft_M12(:,iSpecies) = exp( LogHydroPressureSLeft_M12(:,iSpecies)) 
          HydroPressureSRight_M12(:,iSpecies) = exp(LogHydroPressureSRight_M12(:,iSpecies)) 

           HydroPressureSLeft_P12(:,iSpecies) = exp( LogHydroPressureSLeft_P12(:,iSpecies)) 
          HydroPressureSRight_P12(:,iSpecies) = exp(LogHydroPressureSRight_P12(:,iSpecies)) 

    enddo 

          !! Calculate the Left and Right Faces of the RhoS 
           call calc_kt_facevalues(LogHydroPressure(-1:nAlts+2), LogHydroPressureLeft_M12(1:nAlts), LogHydroPressureRight_M12(1:nAlts), &
                                                                           LogHydroPressureLeft_P12(1:nAlts), LogHydroPressureRight_P12(1:nAlts) )

           HydroPressureLeft_M12(:) = exp( LogHydroPressureLeft_M12(:)) 
          HydroPressureRight_M12(:) = exp(LogHydroPressureRight_M12(:)) 

           HydroPressureLeft_P12(:) = exp( LogHydroPressureLeft_P12(:)) 
          HydroPressureRight_P12(:) = exp(LogHydroPressureRight_P12(:)) 





   do iSpecies = 1, nSpecies
         !! Calculate the Left and Right Faces of the PressureS
          call calc_kt_facevalues(LogPS(:,iSpecies), LogPressureSLeft_M12(:,iSpecies), LogPressureSRight_M12(:,iSpecies), &
                                                     LogPressureSLeft_P12(:,iSpecies), LogPressureSRight_P12(:,iSpecies) )

           PressureSLeft_M12(:,iSpecies) = exp( LogPressureSLeft_M12(:,iSpecies)) 
          PressureSRight_M12(:,iSpecies) = exp(LogPressureSRight_M12(:,iSpecies)) 

           PressureSLeft_P12(:,iSpecies) = exp( LogPressureSLeft_P12(:,iSpecies)) 
          PressureSRight_P12(:,iSpecies) = exp(LogPressureSRight_P12(:,iSpecies)) 

   enddo 



   do iSpecies = 1, nSpecies
         !! Calculate the Left and Right Faces of the Var (Rho) 
          call calc_kt_facevalues(VertVel(:,iSpecies), VelLeft_M12(:,iSpecies), VelRight_M12(:,iSpecies), &
                                                       VelLeft_P12(:,iSpecies), VelRight_P12(:,iSpecies) )
   enddo 



           RhoLeft_M12(:) = 0.0
           RhoRight_M12(:) = 0.0
 
           RhoLeft_P12(:) = 0.0
           RhoRight_P12(:) = 0.0

           do iSpecies = 1, nSpecies
              RhoLeft_M12(1:nAlts) = RhoLeft_M12(1:nAlts) + RhoSLeft_M12(1:nAlts,iSpecies)
              RhoRight_M12(1:nAlts) = RhoRight_M12(1:nAlts) + RhoSRight_M12(1:nAlts,iSpecies)

              RhoLeft_P12(1:nAlts) = RhoLeft_P12(1:nAlts) + RhoSLeft_P12(1:nAlts,iSpecies)
              RhoRight_P12(1:nAlts) = RhoRight_P12(1:nAlts) + RhoSRight_P12(1:nAlts,iSpecies)
           enddo 
 


           PLeft_M12(:) = 0.0
           PRight_M12(:) = 0.0
 
           PLeft_P12(:) = 0.0
           PRight_P12(:) = 0.0

           do iSpecies = 1, nSpecies
              PLeft_M12(1:nAlts) = PLeft_M12(1:nAlts) + PressureSLeft_M12(1:nAlts,iSpecies)
              PRight_M12(1:nAlts) = PRight_M12(1:nAlts) + PressureSRight_M12(1:nAlts,iSpecies)

              PLeft_P12(1:nAlts) = PLeft_P12(1:nAlts) + PressureSLeft_P12(1:nAlts,iSpecies)
              PRight_P12(1:nAlts) = PRight_P12(1:nAlts) + PressureSRight_P12(1:nAlts,iSpecies)
           enddo 

   do iDim = 1, 3
         !! Calculate the Left and Right Faces of the Var (Rho) 
          call calc_kt_facevalues(Vel_GD(:,iDim), VelGDLeft_M12(:,iDim), VelGDRight_M12(:,iDim), &
                                                  VelGDLeft_P12(:,iDim), VelGDRight_P12(:,iDim) )
   enddo 


       VelGDLeft_M12(:,iUp_) = 0.0
       VelGDRight_M12(:,iUp_) = 0.0

       VelGDLeft_P12(:,iUp_) = 0.0
       VelGDRight_P12(:,iUp_) = 0.0

       do iSpecies = 1, nSpecies

            VelGDLeft_M12(1:nAlts,iUp_) = VelGDLeft_M12(1:nAlts,iUp_) + &
                     RhoSLeft_M12(1:nAlts,iSpecies)*VelLeft_M12(1:nAlts,iSpecies)/RhoLeft_M12(1:nAlts)
            VelGDRight_M12(1:nAlts,iUp_) = VelGDRight_M12(1:nAlts,iUp_) + &
                     RhoSRight_M12(1:nAlts,iSpecies)*VelRight_M12(1:nAlts,iSpecies)/RhoRight_M12(1:nAlts)

            VelGDLeft_P12(1:nAlts,iUp_) = VelGDLeft_P12(1:nAlts,iUp_) + &
                     RhoSLeft_P12(1:nAlts,iSpecies)*VelLeft_P12(1:nAlts,iSpecies)/RhoLeft_P12(1:nAlts)
            VelGDRight_P12(1:nAlts,iUp_) = VelGDRight_P12(1:nAlts,iUp_) + &
                     RhoSRight_P12(1:nAlts,iSpecies)*VelRight_P12(1:nAlts,iSpecies)/RhoRight_P12(1:nAlts)
       enddo 


        !! Calculate the Left and Right Faces of the Pressure 
          call calc_kt_facevalues(Gamma_1d(:), GammaLeft_M12(:), GammaRight_M12(:), &
                                               GammaLeft_P12(:), GammaRight_P12(:) )

          do iSpecies = 1, nSpecies
          call calc_kt_facevalues(GammaS_1d(:,iSpecies), GammaSLeft_M12(:,iSpecies), GammaSRight_M12(:,iSpecies), &
                                                         GammaSLeft_P12(:,iSpecies), GammaSRight_P12(:,iSpecies) )
          enddo 



         do iAlt = 1, nAlts

!!!! ============= Bulk Values
             ELeft_M12(iAlt) = &
                 ( 1.0/(GammaLeft_M12(iAlt) - 1.0))*PLeft_M12(iAlt) + &
                   0.5*RhoLeft_M12(iAlt)*&
                  (VelGDLeft_M12(iAlt,iUp_)**2.0 + VelGDLeft_M12(iAlt,iEast_)**2.0 + &
                   VelGDLeft_M12(iAlt,iNorth_)**2.0)

             ERight_M12(iAlt) = &
                 ( 1.0/(GammaRight_M12(iAlt) - 1.0))*PRight_M12(iAlt) + &
                   0.5*RhoRight_M12(iAlt)*&
                  (VelGDRight_M12(iAlt,iUp_)**2.0 + VelGDRight_M12(iAlt,iEast_)**2.0 + &
                   VelGDRight_M12(iAlt,iNorth_)**2.0)

             ELeft_P12(iAlt) = &
                 ( 1.0/(GammaLeft_P12(iAlt) - 1.0))*PLeft_P12(iAlt) + &
                   0.5*RhoLeft_P12(iAlt)* &
                  (VelGDLeft_P12(iAlt,iUp_)**2.0 + VelGDLeft_P12(iAlt,iEast_)**2.0 + &
                   VelGDLeft_P12(iAlt,iNorth_)**2.0)

             ERight_P12(iAlt) = &
                 ( 1.0/(GammaRight_P12(iAlt) - 1.0))*PRight_P12(iAlt) + &
                   0.5*RhoRight_P12(iAlt)* &
                  (VelGDRight_P12(iAlt,iUp_)**2.0 + VelGDRight_P12(iAlt,iEast_)**2.0 + &
                   VelGDRight_P12(iAlt,iNorth_)**2.0)

!!!! ============= Bulk Values
             do iSpecies = 1, nSpecies


!                ESLeft_M12(iAlt,iSpecies) = &
!                    ( 1.0/(GammaSLeft_M12(iAlt,iSpecies) - 1.0))*PressureSLeft_M12(iAlt,iSpecies) + &
!                      0.5*RhoSLeft_M12(iAlt,iSpecies)*&
!                     (VelLeft_M12(iAlt,iSpecies)**2.0 + VelGDLeft_M12(iAlt,iEast_)**2.0 + &
!                      VelGDLeft_M12(iAlt,iNorth_)**2.0)
!
!                ESRight_M12(iAlt,iSpecies) = &
!                    ( 1.0/(GammaSRight_M12(iAlt,iSpecies) - 1.0))*PressureSRight_M12(iAlt,iSpecies) + &
!                      0.5*RhoSRight_M12(iAlt,iSpecies)*&
!                     (VelRight_M12(iAlt,iSpecies)**2.0 + VelGDRight_M12(iAlt,iEast_)**2.0 + &
!                      VelGDRight_M12(iAlt,iNorth_)**2.0)
!
!                ESLeft_P12(iAlt,iSpecies) = &
!                    ( 1.0/(GammaSLeft_P12(iAlt,iSpecies) - 1.0))*PressureSLeft_P12(iAlt,iSpecies) + &
!                      0.5*RhoSLeft_P12(iAlt,iSpecies)*&
!                     (VelLeft_P12(iAlt,iSpecies)**2.0 + VelGDLeft_P12(iAlt,iEast_)**2.0 + &
!                      VelGDLeft_P12(iAlt,iNorth_)**2.0)
!
!                ESRight_P12(iAlt,iSpecies) = &
!                    ( 1.0/(GammaSRight_P12(iAlt,iSpecies) - 1.0))*PressureSRight_P12(iAlt,iSpecies) + &
!                      0.5*RhoSRight_P12(iAlt,iSpecies)*&
!                     (VelRight_P12(iAlt,iSpecies)**2.0 + VelGDRight_P12(iAlt,iEast_)**2.0 + &
!                      VelGDRight_P12(iAlt,iNorth_)**2.0)


                ESLeft_M12(iAlt,iSpecies) = &
                    ( 1.0/(GammaSLeft_M12(iAlt,iSpecies) - 1.0))*PressureSLeft_M12(iAlt,iSpecies) 

                ESRight_M12(iAlt,iSpecies) = &
                    ( 1.0/(GammaSRight_M12(iAlt,iSpecies) - 1.0))*PressureSRight_M12(iAlt,iSpecies) 

                ESLeft_P12(iAlt,iSpecies) = &
                    ( 1.0/(GammaSLeft_P12(iAlt,iSpecies) - 1.0))*PressureSLeft_P12(iAlt,iSpecies) 

                ESRight_P12(iAlt,iSpecies) = &
                    ( 1.0/(GammaSRight_P12(iAlt,iSpecies) - 1.0))*PressureSRight_P12(iAlt,iSpecies) 


             enddo 
         enddo 


!!!! Liou et al. [2006] suggest using the Enthalpy for the numerical speed of sound.
!!!! Calculate the Enthalpy at the cell faces here.


!!! Use the Global Values for Now
    do iAlt = 1, nAlts 
       LiouEnthalpyLeft_M12(iAlt) = &
            0.5*(VelGDLeft_M12(iAlt,iUp_)**2.0 + VelGDLeft_M12(iAlt,iEast_)**2.0 + &
                 VelGDLeft_M12(iAlt,iNorth_)**2.0) + &
            (GammaLeft_M12(iAlt)/(GammaLeft_M12(iAlt) - 1.0))*&
            PLeft_M12(iAlt)/RhoLeft_M12(iAlt)

       LiouEnthalpyRight_M12(iAlt) = &
            0.5*(VelGDRight_M12(iAlt,iUp_)**2.0 + VelGDRight_M12(iAlt,iEast_)**2.0 + &
                 VelGDRight_M12(iAlt,iNorth_)**2.0) + &
            (GammaRight_M12(iAlt)/(GammaRight_M12(iAlt) - 1.0))*&
            PRight_M12(iAlt)/RhoRight_M12(iAlt)

       LiouEnthalpyLeft_P12(iAlt) = &
            0.5*(VelGDLeft_P12(iAlt,iUp_)**2.0 + VelGDLeft_P12(iAlt,iEast_)**2.0 + &
                 VelGDLeft_P12(iAlt,iNorth_)**2.0) + &
            (GammaLeft_P12(iAlt)/(GammaLeft_P12(iAlt) - 1.0))*&
            PLeft_P12(iAlt)/RhoLeft_P12(iAlt)

       LiouEnthalpyRight_P12(iAlt) = &
            0.5*(VelGDRight_P12(iAlt,iUp_)**2.0 + VelGDRight_P12(iAlt,iEast_)**2.0 + &
                 VelGDRight_P12(iAlt,iNorth_)**2.0) + &
            (GammaRight_P12(iAlt)/(GammaRight_P12(iAlt) - 1.0))*&
            PRight_P12(iAlt)/RhoRight_P12(iAlt)

    enddo 

!!! Liou Methodology

   do iAlt = 1, nAlts

         SubCs = sqrt(2.0*( (GammaLeft_M12(iAlt) - 1.0 )/(GammaLeft_M12(iAlt) + 1.0)) *&
                             LiouEnthalpyLeft_M12(iAlt) )
         LiouCSLeft_M12(iAlt) = (SubCs**2.0)/max(SubCs, VelGDLeft_M12(iAlt,iUp_))


         SubCs = sqrt(2.0*( (GammaRight_M12(iAlt) - 1.0 )/(GammaRight_M12(iAlt) + 1.0)) *&
                             LiouEnthalpyRight_M12(iAlt) )
         LiouCSRight_M12(iAlt) = (SubCs**2.0)/max(SubCs, -1.0*VelGDRight_M12(iAlt,iUp_))

         InterfaceCS_M12(iAlt) = min(LiouCSLeft_M12(iAlt), LiouCSRight_M12(iAlt))




         SubCs = sqrt(2.0*( (GammaLeft_P12(iAlt) - 1.0 )/(GammaLeft_P12(iAlt) + 1.0)) *&
                             LiouEnthalpyLeft_P12(iAlt) )
         LiouCSLeft_P12(iAlt) = (SubCs**2.0)/max(SubCs, VelGDLeft_P12(iAlt,iUp_))

         SubCs = sqrt(2.0*( (GammaRight_P12(iAlt) - 1.0 )/(GammaRight_P12(iAlt) + 1.0)) *&
                             LiouEnthalpyRight_P12(iAlt) )
         LiouCSRight_P12(iAlt) = (SubCs**2.0)/max(SubCs, -1.0*VelGDRight_P12(iAlt,iUp_))

         InterfaceCS_P12(iAlt) = min(LiouCSLeft_P12(iAlt), LiouCSRight_P12(iAlt))
   enddo 

  
  MeanPressureS_P12(1:nAlts,1:nSpecies) = 0.5*(PressureSLeft_P12(1:nAlts,1:nSpecies) + PressureSRight_P12(1:nAlts,1:nSpecies))
  MeanPressureS_M12(1:nAlts,1:nSpecies) = 0.5*(PressureSLeft_M12(1:nAlts,1:nSpecies) + PressureSRight_M12(1:nAlts,1:nSpecies))

  MeanHydroPressureS_P12(1:nAlts,1:nSpecies) = 0.5*(HydroPressureSLeft_P12(1:nAlts,1:nSpecies) + HydroPressureSRight_P12(1:nAlts,1:nSpecies))
  MeanHydroPressureS_M12(1:nAlts,1:nSpecies) = 0.5*(HydroPressureSLeft_M12(1:nAlts,1:nSpecies) + HydroPressureSRight_M12(1:nAlts,1:nSpecies))

  MeanHydroPressure_P12(1:nAlts) = 0.5*(HydroPressureLeft_P12(1:nAlts) + HydroPressureRight_P12(1:nAlts))
  MeanHydroPressure_M12(1:nAlts) = 0.5*(HydroPressureLeft_M12(1:nAlts) + HydroPressureRight_M12(1:nAlts))

  MeanRhoS_P12(1:nAlts,1:nSpecies) = 0.5*(RhoSLeft_P12(1:nAlts,1:nSpecies) + RhoSRight_P12(1:nAlts,1:nSpecies))
  MeanRhoS_M12(1:nAlts,1:nSpecies) = 0.5*(RhoSLeft_M12(1:nAlts,1:nSpecies) + RhoSRight_M12(1:nAlts,1:nSpecies))

  MeanRho_P12(1:nAlts) = 0.5*(RhoLeft_P12(1:nAlts) + RhoRight_P12(1:nAlts))
  MeanRho_M12(1:nAlts) = 0.5*(RhoLeft_M12(1:nAlts) + RhoRight_M12(1:nAlts))


  do iAlt = 1, nAlts 
     MeanCS_P12(iAlt) = InterfaceCS_P12(iAlt)
     MeanCS_M12(iAlt) = InterfaceCS_M12(iAlt)
  enddo 

!!! Next, define local mach numbers at the interfaces

   do iAlt = 1, nAlts 
     do iSpecies = 1, nSpecies

        MLeft_M12(iAlt,iSpecies) = &
           VelLeft_M12(iAlt,iSpecies)/MeanCS_M12(iAlt)

        MRight_M12(iAlt,iSpecies) = &
           VelRight_M12(iAlt,iSpecies)/MeanCS_M12(iAlt)

        MLeft_P12(iAlt,iSpecies) = &
           VelLeft_P12(iAlt,iSpecies)/MeanCS_P12(iAlt)

        MRight_P12(iAlt,iSpecies) = &
           VelRight_P12(iAlt,iSpecies)/MeanCS_P12(iAlt)
    
     enddo 
   enddo 

     do iSpecies = 1, nSpecies
        M2Bar_M12(1:nAlts,iSpecies) = &
           0.5*(MLeft_M12(1:nAlts,iSpecies)**2.0 + MRight_M12(1:nAlts,iSpecies)**2.0 )

        M2Bar_P12(1:nAlts,iSpecies) = &
           0.5*(MLeft_P12(1:nAlts,iSpecies)**2.0 + MRight_P12(1:nAlts,iSpecies)**2.0 )
     enddo 

     do iSpecies = 1, nSpecies
      do iAlt = 1, nAlts 

        M2Zero_M12(iAlt,iSpecies) = min(1.0, max(M2Bar_M12(iAlt,iSpecies), MInf)) 
        M2Zero_P12(iAlt,iSpecies) = min(1.0, max(M2Bar_P12(iAlt,iSpecies), MInf)) 

        MZero_M12(iAlt,iSpecies) = sqrt(M2Zero_M12(iAlt,iSpecies))
        MZero_P12(iAlt,iSpecies) = sqrt(M2Zero_P12(iAlt,iSpecies))

      enddo 
     enddo 

     do iSpecies = 1, nSpecies
      do iAlt = 1, nAlts 

        FA_M12(iAlt,iSpecies) = MZero_M12(iAlt,iSpecies)*(2.0 - MZero_M12(iAlt,iSpecies))
        FA_P12(iAlt,iSpecies) = MZero_P12(iAlt,iSpecies)*(2.0 - MZero_P12(iAlt,iSpecies))

      enddo 
     enddo 


   do iSpecies = 1, nSpecies
     do iAlt = 1, nAlts

       MF1P_Left_M12(iAlt,iSpecies) = 0.5*(MLeft_M12(iAlt,iSpecies) + abs(MLeft_M12(iAlt,iSpecies)) )
       MF1N_Left_M12(iAlt,iSpecies) = 0.5*(MLeft_M12(iAlt,iSpecies) - abs(MLeft_M12(iAlt,iSpecies)) )

       MF1P_Right_M12(iAlt,iSpecies) = 0.5*(MRight_M12(iAlt,iSpecies) + abs(MRight_M12(iAlt,iSpecies)) )
       MF1N_Right_M12(iAlt,iSpecies) = 0.5*(MRight_M12(iAlt,iSpecies) - abs(MRight_M12(iAlt,iSpecies)) )

       MF1P_Left_P12(iAlt,iSpecies) = 0.5*(MLeft_P12(iAlt,iSpecies) + abs(MLeft_P12(iAlt,iSpecies)) )
       MF1N_Left_P12(iAlt,iSpecies) = 0.5*(MLeft_P12(iAlt,iSpecies) - abs(MLeft_P12(iAlt,iSpecies)) )

       MF1P_Right_P12(iAlt,iSpecies) = 0.5*(MRight_P12(iAlt,iSpecies) + abs(MRight_P12(iAlt,iSpecies)) )
       MF1N_Right_P12(iAlt,iSpecies) = 0.5*(MRight_P12(iAlt,iSpecies) - abs(MRight_P12(iAlt,iSpecies)) )


     enddo 
  enddo 


   do iSpecies = 1, nSpecies
     do iAlt = 1, nAlts

       MF2P_Left_M12(iAlt,iSpecies) =  0.25*(MLeft_M12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Left_M12(iAlt,iSpecies) = -0.25*(MLeft_M12(iAlt,iSpecies) - 1.0)**2.0

       MF2P_Right_M12(iAlt,iSpecies) =  0.25*(MRight_M12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Right_M12(iAlt,iSpecies) = -0.25*(MRight_M12(iAlt,iSpecies) - 1.0)**2.0

       MF2P_Left_P12(iAlt,iSpecies) =  0.25*(MLeft_P12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Left_P12(iAlt,iSpecies) = -0.25*(MLeft_P12(iAlt,iSpecies) - 1.0)**2.0

       MF2P_Right_P12(iAlt,iSpecies) =  0.25*(MRight_P12(iAlt,iSpecies) + 1.0)**2.0
       MF2N_Right_P12(iAlt,iSpecies) = -0.25*(MRight_P12(iAlt,iSpecies) - 1.0)**2.0

     enddo 
  enddo 


!!! Begin 4th Order Mach Number Polynomials
  do iSpecies = 1, nSpecies
    do iAlt = 1, nAlts 

           if ( abs(MLeft_M12(iAlt,iSpecies)) .ge. 1.0) then 
              MF4P_Left_M12(iAlt,iSpecies) = MF1P_Left_M12(iAlt,iSpecies)
              MF4N_Left_M12(iAlt,iSpecies) = MF1N_Left_M12(iAlt,iSpecies)
           else
              MF4P_Left_M12(iAlt,iSpecies) = MF2P_Left_M12(iAlt,iSpecies)*(1.0 - 16.0*LiouBeta*MF2N_Left_M12(iAlt,iSpecies))
              MF4N_Left_M12(iAlt,iSpecies) = MF2N_Left_M12(iAlt,iSpecies)*(1.0 + 16.0*LiouBeta*MF2P_Left_M12(iAlt,iSpecies))
           endif 


           if ( abs(MRight_M12(iAlt,iSpecies)) .ge. 1.0) then 
              MF4P_Right_M12(iAlt,iSpecies) = MF1P_Right_M12(iAlt,iSpecies)
              MF4N_Right_M12(iAlt,iSpecies) = MF1N_Right_M12(iAlt,iSpecies)
           else
              MF4P_Right_M12(iAlt,iSpecies) = MF2P_Right_M12(iAlt,iSpecies)*(1.0 - 16.0*LiouBeta*MF2N_Right_M12(iAlt,iSpecies))
              MF4N_Right_M12(iAlt,iSpecies) = MF2N_Right_M12(iAlt,iSpecies)*(1.0 + 16.0*LiouBeta*MF2P_Right_M12(iAlt,iSpecies))
           endif 


           if ( abs(MLeft_P12(iAlt,iSpecies)) .ge. 1.0) then 
              MF4P_Left_P12(iAlt,iSpecies) = MF1P_Left_P12(iAlt,iSpecies)
              MF4N_Left_P12(iAlt,iSpecies) = MF1N_Left_P12(iAlt,iSpecies)
           else
              MF4P_Left_P12(iAlt,iSpecies) = MF2P_Left_P12(iAlt,iSpecies)*(1.0 - 16.0*LiouBeta*MF2N_Left_P12(iAlt,iSpecies))
              MF4N_Left_P12(iAlt,iSpecies) = MF2N_Left_P12(iAlt,iSpecies)*(1.0 + 16.0*LiouBeta*MF2P_Left_P12(iAlt,iSpecies))
           endif 


           if ( abs(MRight_P12(iAlt,iSpecies)) .ge. 1.0) then 
              MF4P_Right_P12(iAlt,iSpecies) = MF1P_Right_P12(iAlt,iSpecies)
              MF4N_Right_P12(iAlt,iSpecies) = MF1N_Right_P12(iAlt,iSpecies)
           else
              MF4P_Right_P12(iAlt,iSpecies) = MF2P_Right_P12(iAlt,iSpecies)*(1.0 - 16.0*LiouBeta*MF2N_Right_P12(iAlt,iSpecies))
              MF4N_Right_P12(iAlt,iSpecies) = MF2N_Right_P12(iAlt,iSpecies)*(1.0 + 16.0*LiouBeta*MF2P_Right_P12(iAlt,iSpecies))
           endif 


    enddo 
  enddo 



!!! Begin 5th Order Mach Number Polynomials
  do iSpecies = 1, nSpecies
    do iAlt = 1, nAlts 

        LiouAlpha_M12(iAlt,iSpecies) = (3.0/16.0)*(-4.0 + 5.0*(FA_M12(iAlt,iSpecies)**2.0))
        LiouAlpha_P12(iAlt,iSpecies) = (3.0/16.0)*(-4.0 + 5.0*(FA_P12(iAlt,iSpecies)**2.0))

           if ( abs(MLeft_M12(iAlt,iSpecies)) .ge. 1.0) then 
              PF5P_Left_M12(iAlt,iSpecies) = (1.0/MLeft_M12(iAlt,iSpecies))*MF1P_Left_M12(iAlt,iSpecies)
              PF5N_Left_M12(iAlt,iSpecies) = (1.0/MLeft_M12(iAlt,iSpecies))*MF1N_Left_M12(iAlt,iSpecies)
           else
              PF5P_Left_M12(iAlt,iSpecies) = MF2P_Left_M12(iAlt,iSpecies)*( ( 2.0 - MLeft_M12(iAlt,iSpecies)) - &
                         16.0*LiouAlpha_M12(iAlt,iSpecies)*MLeft_M12(iAlt,iSpecies)*MF2N_Left_M12(iAlt,iSpecies))

              PF5N_Left_M12(iAlt,iSpecies) = MF2N_Left_M12(iAlt,iSpecies)*( (-2.0 - MLeft_M12(iAlt,iSpecies)) + &
                         16.0*LiouAlpha_M12(iAlt,iSpecies)*MLeft_M12(iAlt,iSpecies)*MF2P_Left_M12(iAlt,iSpecies))
           endif 

           if ( abs(MRight_M12(iAlt,iSpecies)) .ge. 1.0) then 
              PF5P_Right_M12(iAlt,iSpecies) = (1.0/MRight_M12(iAlt,iSpecies))*MF1P_Right_M12(iAlt,iSpecies)
              PF5N_Right_M12(iAlt,iSpecies) = (1.0/MRight_M12(iAlt,iSpecies))*MF1N_Right_M12(iAlt,iSpecies)
           else
              PF5P_Right_M12(iAlt,iSpecies) = MF2P_Right_M12(iAlt,iSpecies)*( ( 2.0 - MRight_M12(iAlt,iSpecies)) - &
                         16.0*LiouAlpha_M12(iAlt,iSpecies)*MRight_M12(iAlt,iSpecies)*MF2N_Right_M12(iAlt,iSpecies))

              PF5N_Right_M12(iAlt,iSpecies) = MF2N_Right_M12(iAlt,iSpecies)*( (-2.0 - MRight_M12(iAlt,iSpecies)) + &
                         16.0*LiouAlpha_M12(iAlt,iSpecies)*MRight_M12(iAlt,iSpecies)*MF2P_Right_M12(iAlt,iSpecies))
           endif 


           if ( abs(MLeft_P12(iAlt,iSpecies)) .ge. 1.0) then 
              PF5P_Left_P12(iAlt,iSpecies) = (1.0/MLeft_P12(iAlt,iSpecies))*MF1P_Left_P12(iAlt,iSpecies)
              PF5N_Left_P12(iAlt,iSpecies) = (1.0/MLeft_P12(iAlt,iSpecies))*MF1N_Left_P12(iAlt,iSpecies)
           else
              PF5P_Left_P12(iAlt,iSpecies) = MF2P_Left_P12(iAlt,iSpecies)*( ( 2.0 - MLeft_P12(iAlt,iSpecies)) - &
                         16.0*LiouAlpha_P12(iAlt,iSpecies)*MLeft_P12(iAlt,iSpecies)*MF2N_Left_P12(iAlt,iSpecies))

              PF5N_Left_P12(iAlt,iSpecies) = MF2N_Left_P12(iAlt,iSpecies)*( (-2.0 - MLeft_P12(iAlt,iSpecies)) + &
                         16.0*LiouAlpha_P12(iAlt,iSpecies)*MLeft_P12(iAlt,iSpecies)*MF2P_Left_P12(iAlt,iSpecies))
           endif 

           if ( abs(MRight_P12(iAlt,iSpecies)) .ge. 1.0) then 
              PF5P_Right_P12(iAlt,iSpecies) = (1.0/MRight_P12(iAlt,iSpecies))*MF1P_Right_P12(iAlt,iSpecies)
              PF5N_Right_P12(iAlt,iSpecies) = (1.0/MRight_P12(iAlt,iSpecies))*MF1N_Right_P12(iAlt,iSpecies)
           else
              PF5P_Right_P12(iAlt,iSpecies) = MF2P_Right_P12(iAlt,iSpecies)*( ( 2.0 - MRight_P12(iAlt,iSpecies)) - &
                         16.0*LiouAlpha_P12(iAlt,iSpecies)*MRight_P12(iAlt,iSpecies)*MF2N_Right_P12(iAlt,iSpecies))

              PF5N_Right_P12(iAlt,iSpecies) = MF2N_Right_P12(iAlt,iSpecies)*( (-2.0 - MRight_P12(iAlt,iSpecies)) + &
                         16.0*LiouAlpha_P12(iAlt,iSpecies)*MRight_P12(iAlt,iSpecies)*MF2P_Right_P12(iAlt,iSpecies))
           endif 


    enddo 
  enddo 




!!! Begin 2nd Order Mach Number Polynomials
  do iSpecies = 1, nSpecies
    do iAlt = 1, nAlts 

!!! In Liou et al. [2006]
!
!      MPress_M12(iAlt,iSpecies) = (Kp/FA_M12(iAlt,iSpecies) )*&
!                                max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
!                                (PressureSRight_M12(iAlt, iSpecies) - PressureSLeft_M12(iAlt,iSpecies) )/&
!                                ( MeanRhoS_M12(iAlt,iSpecies)*(MeanCS_M12(iAlt)**2.0))
!
!      MPress_P12(iAlt,iSpecies) = (Kp/FA_P12(iAlt,iSpecies) )*&
!                                max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
!                                (PressureSRight_P12(iAlt, iSpecies) - PressureSLeft_P12(iAlt,iSpecies))/&
!                                ( MeanRhoS_P12(iAlt,iSpecies)*(MeanCS_P12(iAlt)**2.0))
!


       ModifiedZeta(iAlt,iSpecies) = 1.0


!       MPress_M12(iAlt,iSpecies) = LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
!                                 (PressureSRight_M12(iAlt, iSpecies) - PressureSLeft_M12(iAlt,iSpecies) )/&
!                                 ( MeanRhoS_M12(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
!                                   (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 
!
!
!       MPress_P12(iAlt,iSpecies) = LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
!                                 (PressureSRight_P12(iAlt, iSpecies) - PressureSLeft_P12(iAlt,iSpecies) )/&
!                                 ( MeanRhoS_P12(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
!                                   (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 


!!!! Hydrostatic Species Use This one
       MPress_M12(iAlt,iSpecies) = LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
                                 (  (PressureSRight_M12(iAlt, iSpecies) - HydroPressureSRight_M12(iAlt,iSpecies) ) - &
                                    (PressureSLeft_M12(iAlt, iSpecies) - HydroPressureSLeft_M12(iAlt,iSpecies) ) )/ &
                                 ( MeanRhoS_M12(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
                                   (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 

       MPress_P12(iAlt,iSpecies) = LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
                                 (  (PressureSRight_P12(iAlt, iSpecies) - HydroPressureSRight_P12(iAlt,iSpecies) ) - &
                                    (PressureSLeft_P12(iAlt, iSpecies) - HydroPressureSLeft_P12(iAlt,iSpecies) ) )/ &
                                 ( MeanRhoS_P12(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
                                   (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 

!!!!! Non-Hydrostatic Species Should use this version

       if (SubtractHydrostatic(iAlt,iSpecies) .eq. .false.) then

       MPress_P12(iAlt,iSpecies) = LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
                                 (PressureSRight_P12(iAlt, iSpecies) - PressureSLeft_P12(iAlt,iSpecies) )/&
                                 ( MeanRhoS_P12(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
                                   (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 

       MPress_M12(iAlt,iSpecies) = LiouKpS(iAlt,iSpecies)*max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
                                 (PressureSRight_M12(iAlt, iSpecies) - PressureSLeft_M12(iAlt,iSpecies) )/&
                                 ( MeanRhoS_M12(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
                                   (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 


       endif 




!
      ! PU_M12(iAlt,iSpecies) = Ku*PF5P_Left_M12(iAlt,iSpecies)*PF5N_Right_M12(iAlt,iSpecies)*FA_M12(iAlt,iSpecieS)*&
      !                         MeanCS_M12(iAlt)*(RhoSLeft_M12(iAlt,iSpecies) + RhoSRight_M12(iAlt,iSpecies))*&
      !                         (VelRight_M12(iAlt,iSpecies) - VelLeft_M12(iAlt,iSpecies))
!
!       PU_P12(iAlt,iSpecies) = Ku*PF5P_Left_P12(iAlt,iSpecies)*PF5N_Right_P12(iAlt,iSpecies)*FA_P12(iAlt,iSpecieS)*&
!                               MeanCS_P12(iAlt)*(RhoSLeft_P12(iAlt,iSpecies) + RhoSRight_P12(iAlt,iSpecies))*&
!                               (VelRight_P12(iAlt,iSpecies) - VelLeft_P12(iAlt,iSpecies))
 

!!! Modified Numerical Sound speed consistent with Moguen et al. [2011]

        PU_M12(iAlt,iSpecies) = LiouKu*PF5P_Left_M12(iAlt,iSpecies)*PF5N_Right_M12(iAlt,iSpecies)*&
                                (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)*&
                                (RhoSLeft_M12(iAlt,iSpecies) + RhoSRight_M12(iAlt,iSpecies))*&
                                (VelRight_M12(iAlt,iSpecies) - VelLeft_M12(iAlt,iSpecies))

        PU_P12(iAlt,iSpecies) = LiouKu*PF5P_Left_P12(iAlt,iSpecies)*PF5N_Right_P12(iAlt,iSpecies)*&
                                (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)*&
                                (RhoSLeft_P12(iAlt,iSpecies) + RhoSRight_P12(iAlt,iSpecies))*&
                                (VelRight_P12(iAlt,iSpecies) - VelLeft_P12(iAlt,iSpecies))
 

    enddo 
  enddo 


   do iAlt = 1, nAlts 
      do iSpecies = 1, nSpecies

          InterfaceMach_M12(iAlt,iSpecies) =  &
                 MF4P_Left_M12(iAlt,iSpecies) + MF4N_Right_M12(iAlt,iSpecies) &
                    - MPress_M12(iAlt,iSpecies)

          LiouNumericalVelocity_M12(iAlt,iSpecies) = &
                   MeanCS_M12(iAlt)*InterfaceMach_M12(iAlt,iSpecies) 

          InterfaceMach_P12(iAlt,iSpecies) =  &
                 MF4P_Left_P12(iAlt,iSpecies) + MF4N_Right_P12(iAlt,iSpecies) &
                    - MPress_P12(iAlt,iSpecies)
 
          LiouNumericalVelocity_P12(iAlt,iSpecies) = &
                   MeanCS_P12(iAlt)*InterfaceMach_P12(iAlt,iSpecies) 

          InterfacePressure_M12(iAlt,iSpecies) =  &
                 PF5P_Left_M12(iAlt,iSpecies)* PressureSLeft_M12(iAlt,iSpecies) + &
                PF5N_Right_M12(iAlt,iSpecies)*PressureSRight_M12(iAlt,iSpecies) 

          InterfacePressure_P12(iAlt,iSpecies) =  &
                 PF5P_Left_P12(iAlt,iSpecies)* PressureSLeft_P12(iAlt,iSpecies) + &
                PF5N_Right_P12(iAlt,iSpecies)*PressureSRight_P12(iAlt,iSpecies) 
 
      enddo 
   enddo 

      NumericalVelocity_M12(1:nAlts,1:nSpecies) = LiouNumericalVelocity_M12(1:nAlts,1:nSpecies)
      NumericalVelocity_P12(1:nAlts,1:nSpecies) = LiouNumericalVelocity_P12(1:nAlts,1:nSpecies)


  do iSpecies = 1, nSpecies


!             NumericalPressure_P12(1:nAlts,iSpecies) = &
!               (MeanPressureS_P12(1:nAlts,iSpecies) - MeanHydroPressureS_P12(1:nAlts,iSpecies) )&
!                - 0.5*Ku(1:nAlts,iSpecies)*MeanCS_P12(1:nAlts)*&
!               ( (RhoSRight_P12(1:nAlts,iSpecies) )*VelRight_P12(1:nAlts,iSpecies) - &
!                  (RhoSLeft_P12(1:nAlts,iSpecies) )* VelLeft_P12(1:nAlts,iSpecies) )
!
!             NumericalPressure_M12(1:nAlts,iSpecies) = &
!               (MeanPressureS_M12(1:nAlts,iSpecies) - MeanHydroPressureS_M12(1:nAlts,iSpecies) )&
!                - 0.5*Ku(1:nAlts,iSpecies)*MeanCS_M12(1:nAlts)*&
!               ( (RhoSRight_M12(1:nAlts,iSpecies) )*VelRight_M12(1:nAlts,iSpecies) - &
!                  (RhoSLeft_M12(1:nAlts,iSpecies) )* VelLeft_M12(1:nAlts,iSpecies) )

       do iAlt = 1, nAlts

             NumericalPressure_P12(iAlt,iSpecies) = &
               (MeanPressureS_P12(iAlt,iSpecies) - MeanHydroPressureS_P12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
               ( (RhoSRight_P12(iAlt,iSpecies) )*VelRight_P12(iAlt,iSpecies) - &
                  (RhoSLeft_P12(iAlt,iSpecies) )* VelLeft_P12(iAlt,iSpecies) )

             NumericalPressure_M12(iAlt,iSpecies) = &
               (MeanPressureS_M12(iAlt,iSpecies) - MeanHydroPressureS_M12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
               ( (RhoSRight_M12(iAlt,iSpecies) )*VelRight_M12(iAlt,iSpecies) - &
                  (RhoSLeft_M12(iAlt,iSpecies) )* VelLeft_M12(iAlt,iSpecies) )

      
       if (SubtractHydrostatic(iAlt,iSpecies) .eq. .false.) then

             NumericalPressure_P12(iAlt,iSpecies) = &
               (MeanPressureS_P12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
               ( (RhoSRight_P12(iAlt,iSpecies) )*VelRight_P12(iAlt,iSpecies) - &
                  (RhoSLeft_P12(iAlt,iSpecies) )* VelLeft_P12(iAlt,iSpecies) )

             NumericalPressure_M12(iAlt,iSpecies) = &
               (MeanPressureS_M12(iAlt,iSpecies) )&
                - 0.5*Ku(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
               ( (RhoSRight_M12(iAlt,iSpecies) )*VelRight_M12(iAlt,iSpecies) - &
                  (RhoSLeft_M12(iAlt,iSpecies) )* VelLeft_M12(iAlt,iSpecies) )

       endif 
           
       enddo !!iAlt = 1, nAlts
  enddo !!! nSpecies

!!! ==============================================================================
!!! ==============================================================================


!
!            HorizBulkNumericalVelocity_P12(1:nAlts) = &
!              (RhoLeft_P12(1:nAlts)*VelGDLeft_P12(1:nAlts,iUp_) + &
!              RhoRight_P12(1:nAlts)*VelGDRight_P12(1:nAlts,iUp_))/  &
!              (RhoLeft_P12(1:nAlts) +  RhoRight_P12(1:nAlts)) - &
!              Kp(1)*(MeanCS_P12(1:nAlts)/MeanHydroPressure_P12(1:nAlts))*&
!                  ( ( PRight_P12(1:nAlts) - HydroPressureRight_P12(1:nAlts))  - &
!                    (  PLeft_P12(1:nAlts) -  HydroPressureLeft_P12(1:nAlts)) )
! 
!            HorizBulkNumericalVelocity_M12(1:nAlts) = &
!              (RhoLeft_M12(1:nAlts)*VelGDLeft_M12(1:nAlts,iUp_) + &
!              RhoRight_M12(1:nAlts)*VelGDRight_M12(1:nAlts,iUp_))/  &
!              (RhoLeft_M12(1:nAlts) +  RhoRight_M12(1:nAlts)) - &
!              Kp(1)*(MeanCS_M12(1:nAlts)/MeanHydroPressure_M12(1:nAlts))*&
!                  ( (PRight_M12(1:nAlts) - HydroPressureRight_M12(1:nAlts))  - &
!                    ( PLeft_M12(1:nAlts) -  HydroPressureLeft_M12(1:nAlts)) )
! 
!            HorizBulkNumericalVelocity_P12(1:nAlts) = &
!              (RhoLeft_P12(1:nAlts)*VelGDLeft_P12(1:nAlts,iUp_) + &
!              RhoRight_P12(1:nAlts)*VelGDRight_P12(1:nAlts,iUp_))/  &
!              (RhoLeft_P12(1:nAlts) +  RhoRight_P12(1:nAlts)) - &
!              Kp(1)*(MeanCS_P12(1:nAlts)/MeanHydroPressure_P12(1:nAlts))*&
!                  (  PRight_P12(1:nAlts)  - PLeft_P12(1:nAlts) )
! 
!
!           HorizBulkNumericalVelocity_M12(1:nAlts) = &
!              (RhoLeft_M12(1:nAlts)*VelGDLeft_M12(1:nAlts,iUp_) + &
!              RhoRight_M12(1:nAlts)*VelGDRight_M12(1:nAlts,iUp_))/  &
!              (RhoLeft_M12(1:nAlts) +  RhoRight_M12(1:nAlts)) - &
!              Kp(1)*(MeanCS_M12(1:nAlts)/MeanHydroPressure_M12(1:nAlts))*&
!                  ( PRight_M12(1:nAlts) - PLeft_M12(1:nAlts) )
!
            HorizBulkNumericalVelocity_P12(1:nAlts) = &
              0.5*(VelGDLeft_P12(1:nAlts,iUp_) + VelGDRight_P12(1:nAlts,iUp_))

            HorizBulkNumericalVelocity_M12(1:nAlts) = &
              0.5*(VelGDLeft_M12(1:nAlts,iUp_) + VelGDRight_M12(1:nAlts,iUp_))


!!! ===========================================================================
!
!        do iAlt = 1, nAlts
!            HorizBulkNumericalVelocity_P12(iAlt) = &
!              0.5*(VelGDLeft_P12(iAlt,iUp_) + VelGDRight_P12(iAlt,iUp_)) - &
!                  Kp(1)*1.0*(PRight_P12(iAlt) - PLeft_P12(iAlt))/&
!                       (MeanRho_P12(iAlt)*( FA_P12(iAlt,1)*MeanCS_P12(iAlt)) + &
!                        ModifiedZeta(iAlt,1)*dAlt_C(iAlt)/Dt )   
!
!            HorizBulkNumericalVelocity_M12(iAlt) = &
!              0.5*(VelGDLeft_M12(iAlt,iUp_) + VelGDRight_M12(iAlt,iUp_)) - &
!                  Kp(1)*1.0*(PRight_M12(iAlt) - PLeft_M12(iAlt))/&
!                       (MeanRho_M12(iAlt)*( FA_M12(iAlt,1)*MeanCS_M12(iAlt)) + &
!                        ModifiedZeta(iAlt,1)*dAlt_C(iAlt)/Dt )   
!        enddo 




!       MPress_M12(iAlt,iSpecies) = LiouKp*max( (1.0 - M2Bar_M12(iAlt,iSpecies)), 0.0)*&
!                                 (PressureSRight_M12(iAlt, iSpecies) - PressureSLeft_M12(iAlt,iSpecies) )/&
!                                 ( MeanRhoS_M12(iAlt,iSpecies)*MeanCS_M12(iAlt)*&
!                                   (FA_M12(iAlt,iSpecies)*MeanCS_M12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 
!
!
!       MPress_P12(iAlt,iSpecies) = LiouKp*max( (1.0 - M2Bar_P12(iAlt,iSpecies)), 0.0)*&
!                                 (PressureSRight_P12(iAlt, iSpecies) - PressureSLeft_P12(iAlt,iSpecies) )/&
!                                 ( MeanRhoS_P12(iAlt,iSpecies)*MeanCS_P12(iAlt)*&
!                                   (FA_P12(iAlt,iSpecies)*MeanCS_P12(iAlt) + ModifiedZeta(iAlt,iSpecies)*dAlt_C(iAlt)/Dt)  ) 
!


    BulkNumericalVelocity_P12(1:nAlts) = 0.0
    BulkNumericalVelocity_M12(1:nAlts) = 0.0

    do iSpecies = 1, nSpecies
        BulkNumericalVelocity_P12(1:nAlts) = &
        BulkNumericalVelocity_P12(1:nAlts) + &
           ( RhoSLeft_P12(1:nAlts,iSpecies) + RhoSRight_P12(1:nAlts,iSpecies) )*NumericalVelocity_P12(1:nAlts,iSpecies)/&
             (RhoLeft_P12(1:nAlts) + RhoRight_P12(1:nAlts) )

        BulkNumericalVelocity_M12(1:nAlts) = &
        BulkNumericalVelocity_M12(1:nAlts) + &
           ( RhoSLeft_M12(1:nAlts,iSpecies) + RhoSRight_M12(1:nAlts,iSpecies) )*NumericalVelocity_M12(1:nAlts,iSpecies)/&
             (RhoLeft_M12(1:nAlts) + RhoRight_M12(1:nAlts) )
    enddo 




    do iSpecies = 1, nSpecies


       do iAlt = 1, nAlts 

       if (NumericalVelocity_P12(iAlt,iSpecies) .ge. 0.0) then 

          RhoSFlux_P12(iAlt,iSpecies) = &
              (RhoSLeft_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies)) 

          MomentumSFlux_P12(iAlt,iSpecies) = &
              (RhoSLeft_P12(iAlt,iSpecies)*VelLeft_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies)) + &
              NumericalPressure_P12(iAlt,iSpecies)

!          EnergySFlux_P12(iAlt,iSpecies) = &
!              (ESLeft_P12(iAlt,iSpecies) + PressureSLeft_P12(iAlt,iSpecies))*&
!                NumericalVelocity_P12(iAlt,iSpecies) 

          EnergySFlux_P12(iAlt,iSpecies) = &
              ESLeft_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies) 

       else
          RhoSFlux_P12(iAlt,iSpecies) = &
              (RhoSRight_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies)) 

          MomentumSFlux_P12(iAlt,iSpecies) = &
              (RhoSRight_P12(iAlt,iSpecies)*VelRight_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies)) + &
              NumericalPressure_P12(iAlt,iSpecies)

!          EnergySFlux_P12(iAlt,iSpecies) = &
!              (ESRight_P12(iAlt,iSpecies) + PressureSRight_P12(iAlt,iSpecies))*&
!              NumericalVelocity_P12(iAlt,iSpecies) 

          EnergySFlux_P12(iAlt,iSpecies) = &
              ESRight_P12(iAlt,iSpecies)*NumericalVelocity_P12(iAlt,iSpecies) 

       endif


       if (NumericalVelocity_M12(iAlt,iSpecies) .ge. 0.0) then 

          RhoSFlux_M12(iAlt,iSpecies) = &
              (RhoSLeft_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies)) 

          MomentumSFlux_M12(iAlt,iSpecies) = &
              (RhoSLeft_M12(iAlt,iSpecies)*VelLeft_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies)) + &
              NumericalPressure_M12(iAlt,iSpecies)

!          EnergySFlux_M12(iAlt,iSpecies) = &
!              (ESLeft_M12(iAlt,iSpecies) + PressureSLeft_M12(iAlt,iSpecies))*&
!              NumericalVelocity_M12(iAlt,iSpecies) 

          EnergySFlux_M12(iAlt,iSpecies) = &
              ESLeft_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies) 

       else

          RhoSFlux_M12(iAlt,iSpecies) = &
              (RhoSRight_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies)) 

          MomentumSFlux_M12(iAlt,iSpecies) = &
              (RhoSRight_M12(iAlt,iSpecies)*VelRight_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies)) + &
              NumericalPressure_M12(iAlt,iSpecies)

!          EnergySFlux_M12(iAlt,iSpecies) = &
!              (ESRight_M12(iAlt,iSpecies) + PressureSRight_M12(iAlt,iSpecies))*&
!              NumericalVelocity_M12(iAlt,iSpecies) 

          EnergySFlux_M12(iAlt,iSpecies) = &
              ESRight_M12(iAlt,iSpecies)*NumericalVelocity_M12(iAlt,iSpecies) 


       endif

       enddo 
    enddo 

       do iAlt = 1, nAlts 



          if (BulkNumericalVelocity_P12(iAlt) .ge. 0.0) then 

!             EnergyFlux_P12(iAlt) = &
!               ( ELeft_P12(iAlt) + PLeft_P12(iAlt) - HydroPressureLeft_P12(iAlt)  ) &
!                 *BulkNumericalVelocity_P12(iAlt) 

!!!! Not Subtracting off Hydrostatic Background
             EnergyFlux_P12(iAlt) = &
               ( ELeft_P12(iAlt) + PLeft_P12(iAlt) ) &
                 *BulkNumericalVelocity_P12(iAlt) 

!             Momentum_P12(iAlt,1:3) = &
!                RhoLeft_P12(iAlt)*VelGDLeft_P12(iAlt,1:3)*&
!                HorizBulkNumericalVelocity_P12(iAlt) 

!             Momentum_P12(iAlt,1:3) = &
!                RhoLeft_P12(iAlt)*VelGDLeft_P12(iAlt,1:3)*&
!                BulkNumericalVelocity_P12(iAlt) 
 
          else

!             EnergyFlux_P12(iAlt) = &
!               ( ERight_P12(iAlt) + PRight_P12(iAlt) - HydroPressureRight_P12(iAlt) ) &
!                 *BulkNumericalVelocity_P12(iAlt) 


!!!! Not Subtracting off Hydrostatic Background
              EnergyFlux_P12(iAlt) = &
                ( ERight_P12(iAlt) + PRight_P12(iAlt) ) &
                  *BulkNumericalVelocity_P12(iAlt) 
 
!             Momentum_P12(iAlt,1:3) = &
!                RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,1:3)*&
!                HorizBulkNumericalVelocity_P12(iAlt) 
!
!             Momentum_P12(iAlt,1:3) = &
!                RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,1:3)*&
!                BulkNumericalVelocity_P12(iAlt) 

          endif

          if (BulkNumericalVelocity_M12(iAlt) .ge. 0.0) then 

!             EnergyFlux_M12(iAlt) = &
!               ( ELeft_M12(iAlt) + PLeft_M12(iAlt) - HydroPressureLeft_M12(iAlt) )*&
!                 BulkNumericalVelocity_M12(iAlt) 

!!!! Not Subtracting off Hydrostatic Background
             EnergyFlux_M12(iAlt) = &
               ( ELeft_M12(iAlt) + PLeft_M12(iAlt))*&
              BulkNumericalVelocity_M12(iAlt) 

!             Momentum_M12(iAlt,1:3) = &
!                RhoLeft_M12(iAlt)*VelGDLeft_M12(iAlt,1:3)*&
!                HorizBulkNumericalVelocity_M12(iAlt) 
 
!             Momentum_M12(iAlt,1:3) = &
!                RhoLeft_M12(iAlt)*VelGDLeft_M12(iAlt,1:3)*&
!                BulkNumericalVelocity_M12(iAlt) 

          else
 
!             EnergyFlux_M12(iAlt) = &
!               ( ERight_M12(iAlt) + PRight_M12(iAlt) - HydroPressureRight_M12(iAlt))*&
!                 BulkNumericalVelocity_M12(iAlt) 

             EnergyFlux_M12(iAlt) = &
               ( ERight_M12(iAlt) + PRight_M12(iAlt))*&
              BulkNumericalVelocity_M12(iAlt) 

!              Momentum_M12(iAlt,1:3) = &
!                 RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,1:3)*&
!                 HorizBulkNumericalVelocity_M12(iAlt) 

!             Momentum_M12(iAlt,1:3) = &
!                RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,1:3)*&
!                BulkNumericalVelocity_M12(iAlt) 

          endif


!!!! Vertical Advection of Horizontal Momentum
!!!! Using No Rusanov Fluxes
!
!          do iDim = 1, 3
!
!            Momentum_P12(iAlt,iDim) = & 
!                 0.5*(  RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,iDim) + &
!                         RhoLeft_P12(iAlt)* VelGDLeft_P12(iAlt,iDim))*&
!                 HorizBulkNumericalVelocity_P12(iAlt) 
!
!            Momentum_M12(iAlt,iDim) = & 
!                 0.5*(  RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,iDim) + &
!                         RhoLeft_M12(iAlt)* VelGDLeft_M12(iAlt,iDim))*&
!                 HorizBulkNumericalVelocity_M12(iAlt) 
!
!          enddo 
!
!

!!!! New Technique for Energy Fluxes
!!! No Rusanov Correction
!
!             EnergyFlux_M12(iAlt) = &
!              0.5*( ERight_M12(iAlt) + PRight_M12(iAlt) - HydroPressureRight_M12(iAlt) + &
!                     ELeft_M12(iAlt) + PLeft_M12(iAlt) - HydroPressureLeft_M12(iAlt)  )*&
!                 HorizBulkNumericalVelocity_M12(iAlt) 
!
!             EnergyFlux_P12(iAlt) = &
!              0.5*( ERight_P12(iAlt) + PRight_P12(iAlt) - HydroPressureRight_P12(iAlt) + &
!                     ELeft_P12(iAlt) + PLeft_P12(iAlt) - HydroPressureLeft_P12(iAlt)  )*&
!                 HorizBulkNumericalVelocity_P12(iAlt) 
!

!!!! New Technique for Energy Fluxes
!!!! With Rusanov Correction
!
!             EnergyFlux_M12(iAlt) = &
!              0.5*( ERight_M12(iAlt) + PRight_M12(iAlt) - HydroPressureRight_M12(iAlt) + &
!                     ELeft_M12(iAlt) + PLeft_M12(iAlt) - HydroPressureLeft_M12(iAlt)  )*&
!                 HorizBulkNumericalVelocity_M12(iAlt) - &
!                   0.5*Kp(1)*MeanCS_M12(iAlt)*(  ERight_M12(iAlt) + PRight_M12(iAlt) - ELeft_M12(iAlt) - PLeft_M12(iAlt) )
!
!             EnergyFlux_P12(iAlt) = &
!              0.5*( ERight_P12(iAlt) + PRight_P12(iAlt) - HydroPressureRight_P12(iAlt) + &
!                     ELeft_P12(iAlt) + PLeft_P12(iAlt) - HydroPressureLeft_P12(iAlt)  )*&
!                 HorizBulkNumericalVelocity_P12(iAlt) - &
!                   0.5*Kp(1)*MeanCS_P12(iAlt)*(  ERight_P12(iAlt) + PRight_P12(iALt) - ELeft_P12(iAlt) - PLeft_P12(iAlt) )
!

!             EnergyFlux_M12(iAlt) = &
!              0.5*( ERight_M12(iAlt) + PRight_M12(iAlt)  + ELeft_M12(iAlt) + PLeft_M12(iAlt)  )*HorizBulkNumericalVelocity_M12(iAlt) - &
!                   0.5*Kp(1)*MeanCS_M12(iAlt)*(  ERight_M12(iAlt) - ELeft_M12(iAlt) )
!
!             EnergyFlux_P12(iAlt) = &
!              0.5*( ERight_P12(iAlt) + PRight_P12(iAlt) +  ELeft_P12(iAlt) + PLeft_P12(iAlt) )*HorizBulkNumericalVelocity_P12(iAlt) - &
!                   0.5*Kp(1)*MeanCS_P12(iAlt)*(  ERight_P12(iAlt)  - ELeft_P12(iAlt) )
!
!             EnergyFlux_M12(iAlt) = &
!              0.5*( ERight_M12(iAlt) + PRight_M12(iAlt)  + ELeft_M12(iAlt) + PLeft_M12(iAlt)  )*HorizBulkNumericalVelocity_M12(iAlt) - &
!                   0.005*Kp(1)*MeanCS_M12(iAlt)*(  ERight_M12(iAlt) - ELeft_M12(iAlt) )
!
!             EnergyFlux_P12(iAlt) = &
!              0.5*( ERight_P12(iAlt) + PRight_P12(iAlt) +  ELeft_P12(iAlt) + PLeft_P12(iAlt) )*HorizBulkNumericalVelocity_P12(iAlt) - &
!                   0.005*Kp(1)*MeanCS_P12(iAlt)*(  ERight_P12(iAlt)  - ELeft_P12(iAlt) )
!


!!!! Using Rusanov Fluxes
          do iDim = 1, 3

            Momentum_P12(iAlt,iDim) = & 
                 0.5*(  RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,iDim) + &
                         RhoLeft_P12(iAlt)* VelGDLeft_P12(iAlt,iDim))*&
                 HorizBulkNumericalVelocity_P12(iAlt) - &
                   0.5*Kp(1)*MeanCS_P12(iAlt)*(  RhoRight_P12(iAlt)*VelGDRight_P12(iAlt,iDim) - &
                                            RhoLeft_P12(iAlt)* VelGDLeft_P12(iAlt,iDim))

            Momentum_M12(iAlt,iDim) = & 
                 0.5*(  RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,iDim) + &
                         RhoLeft_M12(iAlt)* VelGDLeft_M12(iAlt,iDim))*&
                 HorizBulkNumericalVelocity_M12(iAlt) - & 
                   0.5*Kp(1)*MeanCS_M12(iAlt)*(  RhoRight_M12(iAlt)*VelGDRight_M12(iAlt,iDim) - &
                                            RhoLeft_M12(iAlt)* VelGDLeft_M12(iAlt,iDim))

          enddo 




       enddo 

     do iAlt = 1, nAlts
           LeftRadius(iAlt) = 0.5*(RadDist(iAlt) + RadDist(iAlt-1))
           RightRadius(iAlt) = 0.5*(RadDist(iAlt) + RadDist(iAlt+1))
     enddo 

    do iSpecies = 1, nSpecies

       RhoSFlux(1:nAlts,iSpecies) = &
            ( (RightRadius(1:nAlts)**2.0)*RhoSFlux_P12(1:nAlts,iSpecies) - &
               (LeftRadius(1:nAlts)**2.0)*RhoSFlux_M12(1:nAlts,iSpecies) )/&
              dAlt_C(1:nAlts)

       EnergySFluxes(1:nAlts,iSpecies) = &
            ( (RightRadius(1:nAlts)**2.0)*EnergySFlux_P12(1:nAlts,iSpecies) - &
               (LeftRadius(1:nAlts)**2.0)*EnergySFlux_M12(1:nAlts,iSpecies) )/&
              dAlt_C(1:nAlts)


      do iAlt = 1, nAlts

!!! This is the total flux in the center of the cell
!!! Need to Scale this up by R^2
!!! Use a Linear mean to estimate the cell fluxes

        VS1D_TotalRhoFluxes(iAlt,iSpecies) = &
         0.5*( (RadDist(iAlt)**2.0)/(2575.0e+03)**2.0)*(RhoSFlux_P12(iAlt,iSpecies) + RhoSFlux_M12(iAlt,iSpecies))/Mass(iSpecies)

      enddo 

       MomentumSFlux(1:nAlts,iSpecies) = &
            ( (RightRadius**2.0)*MomentumSFlux_P12(1:nAlts,iSpecies) - &
               (LeftRadius**2.0)*MomentumSFlux_M12(1:nAlts,iSpecies) )/&
              dAlt_C(1:nAlts)

    enddo 

       EnergyFluxes(1:nAlts) = &
            ( (RightRadius**2.0)*EnergyFlux_P12(1:nAlts) - &
               (LeftRadius**2.0)*EnergyFlux_M12(1:nAlts))/&
              dAlt_C(1:nAlts)

!
!       EnergyFluxes(1:nAlts) = &
!       EnergyFluxes(1:nAlts) + &
!              HydroPressure(1:nAlts)*&
!               ( (RightRadius**2.0)*BulkNumericalVelocity_P12(1:nAlts) - &
!                  (LeftRadius**2.0)*BulkNumericalVelocity_M12(1:nAlts))/&
!                   dAlt_C(1:nAlts)


     do iDim = 1, 3
       MomentumFluxes(1:nAlts,iDim) = &
            ( (RightRadius**2.0)*Momentum_P12(1:nAlts,iDim) - &
               (LeftRadius**2.0)*Momentum_M12(1:nAlts,iDim))/&
              dAlt_C(1:nAlts)
     enddo 


end subroutine calc_all_fluxes_hydro




 subroutine calc_kt_facevalues(Var, VarLeft_M12, VarRight_M12, &
                                    VarLeft_P12, VarRight_P12)
 
 
   use ModVertical, only: dAlt_F, InvDAlt_F
   use ModSizeGITM, only: nAlts
   use ModLimiterGitm
 
   implicit none
   
   real, intent(in) :: Var(-1:nAlts+2)
   real, intent(out):: VarLeft_P12(1:nAlts), VarRight_P12(1:nAlts)
   real, intent(out):: VarLeft_M12(1:nAlts), VarRight_M12(1:nAlts)
 
   real :: dVarUp, dVarDown, dVarLimited(0:nAlts+1)
 
   integer :: i


!!!!!! TREAT THE LOWER BOUNDARY SEPARATELY

        do i=0,nAlts+1
             dVarUp            = (Var(i+1) - Var(i))   * InvDAlt_F(i+1)
             dVarDown          = (Var(i)   - Var(i-1)) * InvDAlt_F(i)
             dVarLimited(i) = Limiter_mc(dVarUp, dVarDown)
        end do
 
 
        do i=1,nAlts
            VarLeft_M12(i) = Var(i-1) + 0.5*dVarLimited(i-1) * dAlt_F(i-1)
           VarRight_M12(i) = Var(i  ) - 0.5*dVarLimited(i  ) * dAlt_F(i  )
      
            VarLeft_P12(i) = Var(i  ) + 0.5*dVarLimited(i  ) * dAlt_F(i  )
           VarRight_P12(i) = Var(i+1) - 0.5*dVarLimited(i+1) * dAlt_F(i+1)
        end do
 

 end subroutine calc_kt_facevalues

